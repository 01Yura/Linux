**Тестирование программного обеспечения (Software Testing)** — проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённым образом.

**Цель тестирования** — проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи программы.

Для чего мы тестируем:
- проверка соответствия требованиям (ожидание - реальность)
- для обнаружения проблем на ранних этапах разработки (или при анализе требований от бизнес аналитика и системного аналитика)
- обнаружение вариантов использования не по прямому назначению
- повышение лояльности клиента к компании и продукту (любой негатив влияет на это)

                    QA/QC/Testing

**Обеспечение качества (QA — Quality Assurance)** и **контроль качества (QC — Quality Control)**
— эти термины похожи на взаимозаменяемые, но разница между обеспечением качества и контролем качества все-таки есть, хоть на практике процессы и имеют некоторую схожесть.

QA (Quality Assurance) — Обеспечение качества продукта — изучение возможностей по изменению и улучшению процесса разработки, улучшению коммуникаций в команде, где тестирование является только одним из аспектов обеспечения качества.
- проверка требований к ПО
- оценка рисков (какие могут возникнуть проблемы, что может пойти не так)
- планирование как улучшить качество продукта
- подготовка тестовой документации, тестового окружения
- тестирование
- анализ результатов тестирования

QC (Quality Control) — Контроль качества продукта — анализ результатов тестирования и качества новых версий выпускаемого продукта.
- проверка насколько ПО готово к релизу
- проверка соответствия требований и качества

Testing (тестирование) - прохождение по шагам по готовой тестовой документации, где уже есть ОР и мы лишь выставляем ФР

Принципы тестирования:
1. Тестирование демонстрирует наличие дефектов (благодаря чему мы можем снизить вероятность наличия деефектов, но не гарантирует их полного отсутствия)
2. Исчерпывающее тестирование не возможно (полное тестирование с использованием всех входных комбинаций и предусловий невоможно, за искл нек случаев)
3. Раннее тестирование (начинать тестирование при разработке ПО надо начинать как можно раньше)
4. Скопление дефектов (большая часть багов находится в ограниченном количестве модулей)
5. Парадокс Пестицида - если повторять одни и те же тесты снова и снова, то в какой-то момент этот набор тестов перестает выявлять новые баги
6. Тестирование зависит от контекста (например банковкое приложение тестируется иначе чем новостной портал)
7. Заблуждение об отсутствии ошибок (отсутствие багов, не всегда значит готовность ПО к релизу, система должна быть удобна и удовлетворять потребности пользователей)

                    Верификация и валидация

Верификация - это процесс проверки того, что наще ПО соответствует спецификациям, требованиям, документации (которая сформулирована еще в начале). Делаем ли мы продукт правильно?

Валидация - это процесс проверки того, соответствует ли конечный продукт ожиданиям и потребностям пользователей. Делаем ли мы правильный продукт?

Пример с посадкой аэробуса A310 и закрылками/кручение колес.

Документация бывает 
- Проэктная (описывает весь проэкт включая временные рамки, бюджет, людской ресурс, оборудование, этапы, сроки, риски)
- Продуктовая (это техническая спецификация, архитектура, взаимодействие компонетнов, руководсво пользователя, руководсво админа, API документация, руководсво по тестирования и развертыванию, FAQ )

                    Tребования

Требования - это спецификация (описание) того, что должно быть реализовано.
Без технических деталей

Атрибуты требований:
1 Полнота — в требовании должна содержаться вся необходимая для реализации функциональности информация.
8 Модифицируемость — в каждое требование можно внести изменение.
2 Корректность — точное описание разрабатываемого функционала.
3 Недвусмысленность — требование должно содержать однозначные формулировки.
4 Непротиворечивость — требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам.
5 Проверяемость — формулировка требований таким образом, чтобы можно было выставить однозначный вердикт, выполнено все в соответствии с требованиями или нет.
6 Приоритетность — у каждого требования должен быть приоритет(количественная оценка степени значимости требования). Этот атрибут позволит грамотно управлять ресурсами на проекте.
7 Атомарность — требование нельзя разбить на отдельные части без потери деталей.
9 Прослеживаемость — каждое требование должно иметь уникальный идентификатор, по которому на него можно сослаться.

                        SDLC

SDLC (Software Development Life Cycle) - это жизненный цикл разработки программного обеспечения. Он представляет собой структурированный процесс, состоящий из различных фаз и этапов, которые выполняются при создании программного продукта.

1 Анализ и сбор требований: на этом этапе происходит определение и сбор требований к программному продукту. Проводится исследование, выявляются потребности пользователей и определяются функциональные и нефункциональные требования.
2 Проектирование: на этом этапе разрабатывается архитектура и дизайн программного продукта. Определяются компоненты системы, их взаимосвязи и интерфейсы.
3 Разработка: на этом этапе происходит непосредственная реализация программного продукта. Программисты пишут код, создают функциональность и выполняют тестирование единиц кода.
4 Тестирование: на этом этапе проводится тестирование программного продукта с целью выявления ошибок, дефектов и проверки его соответствия требованиям. Включает в себя функциональное тестирование, интеграционное тестирование, системное тестирование и другие виды тестирования.
5 Развёртывание: на этом этапе программный продукт готовится к выпуску и установке на целевой среде. Включает в себя подготовку документации, инсталляцию, настройку и обучение пользователей.
6 Эксплуатация и поддержка: после развёртывания программного продукта происходит его эксплуатация, поддержка и обновление. Ведется мониторинг работы системы, исправление ошибок и добавление новой функциональности.

                        STLC


STLC (Software Testing Life Cycle) - это жизненный цикл тестирования программного обеспечения. Он представляет собой структурированный процесс, состоящий из различных фаз и этапов, которые выполняются при проведении тестирования программного продукта.

1. Планирование: на этом этапе определяются цели тестирования, разрабатывается план тестирования и определяются ресурсы, необходимые для выполнения тестов.
2. Анализ требований и создание тестовой документации: на этом этапе изучаются требования к программному продукту и создается тестовая документация, включающая тестовые случаи, тестовые сценарии и другие артефакты.
3 Дизайн тестов: на этом этапе разрабатывается стратегия тестирования и определяются методы, подходы и техники, которые будут использоваться для проведения тестов. Создаются тестовые случаи и сценарии на основе требований и анализа продукта.
4 Подготовка к выполнению тестов: на этом этапе создается тестовая среда, включающая необходимые инструменты и данные для проведения тестов. Также выполняется подготовка тестовых сценариев и проверка настроек тестовой среды.
5 Выполнение тестов: на этом этапе проводятся тестирование по определенным тестовым случаям и сценариям. Результаты тестов регистрируются, ошибки и дефекты отслеживаются и отчеты о тестировании создаются.
6 Анализ результатов тестирования: на этом этапе происходит анализ результатов тестирования, выявление и регистрация дефектов. Оценивается качество продукта и принимаются решения о его готовности к выпуску.
7 Завершение: на этом этапе подводятся итоги тестирования, создается финальный отчет о выполненном тестировании, проводится оценка процесса тестирования и выявление возможных улучшений.

                        Severity vs Priority

    Severity (серьезность) - показывает степень ущерба, который наносится проекту существованием дефекта. Severity выставляется тестировщиком.
Стоит учесть что Серьезность применяется в основном к баг-репортам

Блокирующий (S1 – Blocker) - тестирование значительной части функциональности вообще недоступно. Блокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна.

Критический (S2 – Critical) - критическая ошибка, неправильно работающая ключевая бизнес-логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, то есть не работает важная часть одной какой-либо функции либо не работает значительная часть, но имеется workaround (обходной путь/другие входные точки), позволяющий продолжить тестирование.

Значительный (S3 – Major) - не работает важная часть одной какой-либо функции/бизнес-логики, но при выполнении специфических условий, либо есть workaround, позволяющий продолжить ее тестирование либо не работает не очень значительная часть какой-либо функции. Также относится к дефектам с высокими visibility – обычно не сильно влияющие на функциональность дефекты дизайна, которые, однако, сразу бросаются в глаза.

Незначительный (S4 – Minor) - часто ошибки GUI, которые не влияют на функциональность, но портят юзабилити или внешний вид. Также незначительные функциональные дефекты, либо которые воспроизводятся на определенном устройстве.

Тривиальный (S5 – Trivial) - почти всегда дефекты на GUI — опечатки в тексте, несоответствие шрифта и оттенка и т.п., либо плохо воспроизводимая ошибка, не касающаяся бизнес-логики, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта

    Срочность (priority) - показывает, как быстро дефект должен быть устранён. Priority выставляется менеджером, тимлидом или заказчиком

P1 Высокий (High) - Критическая для проекта ошибка. Должна быть исправлена как можно быстрее.
P2 Средний (Medium) - Не критичная для проекта ошибка, однако требует обязательного решения.
P3 Низкий (Low) - Наличие данной ошибки не является критичным и не требует срочного решения. Может быть исправлена, когда у команды появится время на ее устранение.

                   Пирамида тестирования

Это группировка тестов по уровню детализации и назначению
4 уровня: (снизу вверх)
   
    - Модульное тестирование (юнит-тестирование) компонентный уровень
Всегда автоматизируют, им обычно занимается разраб, этих тестов больше, они выполняются быстрее всех и требуют меньше ресурсов, и они не зависят от других модулей (н-р в калькуляторе тестируем функцию сложение, которая не зависит от умножения)
Тут используется метод белого ящика
Unit-тесты занимают основное место в пирамиде, так как они:
1 Наименее затратные по времени и ресурсам.
2 Проверяют отдельные компоненты, что позволяет быстро обнаруживать и устранять ошибки в них.
Модульное тестировпнре подращумевает доступ к коду и его понимание. Обычный тестер не делает можкльное тестировпние, так как не шарит в коде. Но не надо путать модульное тестирование как уровень и темтирование отдельных модулей. Мы можем тестировать отдельные модули.
В 99% разработкой модульных тестов занимается разработчик, при нахождении ошибки на этом уровне не создается баг-репортов. Разработчик находит баг, правит, запускает и проверяет (абстрактно говоря это разработка через тестирование) и так по новой, пока тест не будет пройден успешно.


    - Интеграционное тестирование
Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в английских статьях называют service test или API test.
Компоненты ПО или системы взаимодействуют с тестируемым модулем с помощью интерфейсов. Это проверки API, работы сервисов (проверка логов на сервере, записи в БД) и т.п. Отдельно отмечу, что в интеграционном тестировании, выполняются как функциональные (проверка по ТЗ), так и нефункциональные проверки (нагрузка на связку компонент). На этом уровне используется либо серый, либо черный ящик.
Имеют более высокий уровень абстракции и сложности, чем Unit-тесты, поэтому их меньше, но они все еще затратны.

В интеграционном тестировании есть 3 основных способа тестирования:
    1 Снизу вверх (Bottom Up Integration): все мелкие части модуля собираются в один модуль и тестируются. Далее собираются следующие мелкие модули в один большой и тестируется с предыдущим и т.д. Например, функция публикации фото в соц. профиле состоит из 2 модулей: загрузчик и публикатор. Загрузчик, в свою очередь, состоит из модуля компрессии и отправки на сервер. Публикатор состоит из верификатора (проверяет подлинность) и управления доступом к фотографии. В интеграционном тестировании соберем модули загрузчика и проверим, потом соберем модули публикатора, проверим и протестируем взаимодействие загрузчика и публикатор.

    2 Сверху вниз (Top Down Integration): сначала проверяем работу крупных модулей, спускаясь ниже добавляем модули уровнем ниже. На этапе проверки уровней выше данные, необходимые от уровней ниже, симулируются.Например, проверяем работу загрузчика и публикатора. Руками (создаем функцию-заглушку) передаем от загрузчика публикатору фото, которое якобы было обработано компрессором.

    3 Большой взрыв ("Big Bang" Integration): собираем все реализованные модули всех уровней, интегрируем в систему и тестируем. Если что-то не работает или недоработали, то фиксим или дорабатываем.

    - Системное тестирование
Системный уровень проверят взаимодействие тестируемого ПО с системой по функциональным и нефункциональным требованиям.
Важно тестировать на максимально приближенном окружении, которое будет у конечного пользователя.
На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.
На этом уровне используют черный ящик. Интеграционный уровень позволяет верифицировать требования (проверить соответствие ПО прописанным требованиям).
    
    - Приемочное тестирование
Также часто называют E2E тестами (End-2-End) или сквозными. На этом уровне происходит валидация требований (проверка работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне).
Проверка требований производится на наборе приемочных тестов. Они разрабатываются на основе требований и возможных способах использования ПО.
Отмечу, что приемочные тесты проводят, когда (1) продукт достиг необходимо уровня качества и (2) заказчик ПО ознакомлен с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).
Проверяют приложение на уровне пользователя, оценивая его работу в реальных условиях.
Более медленные и затратные, так как они эмулируют действия пользователя на более высоком уровне.

                        Техника тест-дизайна 

Техника тест-дизайна - это систематический подход к планированию, созданию и выбору тестовых случаев и данных для тестирования программного обеспечения с использованием определенных методов и стратегий

Техника тест-дизайна - это набор методов и инструментов, используемых для разработки тестовых случаев на основе заранее определенных критериев и анализа требований. Она позволяет структурировать и оптимизировать процесс тестирования, обеспечивая максимальное покрытие функциональности и возможных сценариев использования программного продукта.

1 Увеличение покрытия тестирования: Техники тест-дизайна помогают создавать тесты, которые охватывают различные аспекты программного обеспечения, включая различные варианты использования и возможные ошибки.
2 Эффективное использование ресурсов: Позволяют оптимизировать количество тестовых случаев и ресурсы, необходимые для тестирования, снижая издержки и ускоряя процесс разработки.
3 Повышение качества программного обеспечения: Создание более полного и эффективного плана тестирования способствует выявлению ошибок и недочетов в ранние стадии разработки, что помогает улучшить качество программы и снизить вероятность возникновения проблем после выпуска в эксплуатацию.

    Эквивалентное разделение

Эквивалентное разделение подразумевает разбиение тестовых данных на классы по какому-то признаку. 
Если мы выбираем в качестве техники тест-дизайна эквивалентное разделение, это означает, что мы будем тестировать только несколько значений из каждого класса элементов. Помните, что это не гарантирует отсутствия ошибок в остальных значениях, не охваченных тестами. Мы лишь предполагаем, что использование нескольких элементов из каждой группы будет достаточно показательным.
Эквивалентное разделение — хорошее решение для случаев, когда вы имеете дело с большим объемом входящих данных или множеством одинаковых вариантов ввода. В противном случае, возможно, имеет смысл более тщательно охватить продукт тестами.

    Анализ граничных значений

Анализ граничных значений в чем-то похож на эквивалентное разделение. Можно даже сказать, что оно лежит в основе эквивалентном разбиении. Но есть некоторые отличия.
При анализе граничных значений мы тоже группируем данные по эквивалентным классам, но проверяем не значения из определенного класса, а граничные значения — те, которые находятся на «границах» классов.

    Переход состояний

Диаграмма перехода состояний визуализирует состояния программы в разные периоды времени и на разных этапах использования. Визуальную информацию воспринимать проще, чем текст. Таким образом, техника перехода состояний позволяет быстрее получить максимальное тестовое покрытие.
Допустим, мы тестируем систему, которая предлагает ограниченное количество попыток ввести правильный пароль. Если пользователь не введет правильный пароль 3 раза, система блокирует доступ (временно или постоянно).

    Попарное тестирование

Попарное тестирование основано на математических алгоритмах, а именно на комбинаторике. Оно позволяет создавать уникальные пары и тестировать огромное количество поступающих данных в разных сочетаниях, но расчеты могут быть сложными.
Чтобы охватить тестовыми сценариями максимум фич и при этом потратить минимальное время на тестирование, нужно правильно сопоставлять данные, комбинируя пары определенным образом на основе расчетов.

                        Виды тестирование (классификация)

1. Классификация по запуску кода на исполнение:
- Статическое тестирование — процесс тестирования, который проводится для верификации практически любого артефакта разработки (любое документальное, программное или техническое средство, созданное или используемое в процессе разработки): программного кода компонент, требований, системных спецификаций, функциональных спецификаций, документов проектирования и архитектуры программных систем и их компонентов. Проводится без запуска програмного кода приложения
- Динамическое тестирование — тестирование проводится на работающей системе, не может быть осуществлено без запуска программного кода приложения. 

2. Классификация по доступу к коду и архитектуре:
- Тестирование белого ящика — метод тестирования ПО, который предполагает полный доступ к коду проекта.
- Тестирование серого ящика — метод тестирования ПО, который предполагает частичный доступ к коду проекта (комбинация White Box и Black Box методов).
- Тестирование чёрного ящика — метод тестирования ПО, который не предполагает доступа (полного или частичного) к системе. Основывается на работе исключительно с внешним интерфейсом тестируемой системы.

3. Классификация по уровню детализации приложения:
- Модульное тестирование — проводится для тестирования какого-либо одного логически выделенного и изолированного элемента (модуля) системы в коде (то есть небольшой изолированной части кода, обычно функции или метода). Проводится самими разработчиками, так как предполагает полный доступ к коду. Обычно автоматизируются. 
- Интеграционное тестирование — тестирование, направленное на проверку корректности взаимодействия нескольких модулей, объединенных в единое целое.
- Системное тестирование — процесс тестирования системы, на котором проводится не только функциональное тестирование, но и оценка характеристик качества системы — ее устойчивости, надежности, безопасности и производительности.
- Приёмочное тестирование — проверяет соответствие системы потребностям, требованиям и бизнес-процессам пользователя.

4. Классификация по степени автоматизации:
- Ручное тестирование
- Автоматизированное тестирование

5. Классификация по принципам работы с приложением
- Позитивное тестирование — тестирование, при котором используются только корректные данные.
- Негативное тестирование — тестирование приложения, при котором используются некорректные данные и выполняются некорректные операции.

6. Классификация по уровню функционального тестирования:
- Дымовое тестирование (smoke test) — тестирование, выполняемое на новой сборке, с целью подтверждения того, что программное обеспечение стартует и выполняет основные для бизнеса функции.
- Тестирование критического пути (critical path) — направлено для проверки функциональности, используемой обычными пользователями во время их повседневной деятельности.
- Расширенное тестирование (extended) — направлено на исследование всей заявленной в требованиях функциональности.
- Проверочное тестирование (sanity test) - тестирование новой фичи, или определенной части системы, которая была добавлена или переработана.
- Регрессионное тестирование (регресс, regression testing) - повторное тестирование системы после внесения изменений, чтобы убедится, что новые фичи не нарушили существующую функциональность. 

Например есть 1000 тестов. 100 это smoke, 600-700 это sanity, 200 regression

7. Классификация в зависимости от исполнителей:
- Альфа-тестирование — является ранней версией программного продукта. Может выполняться внутри организации-разработчика с возможным частичным привлечением конечных пользователей.
- Бета-тестирование — программное обеспечение, выпускаемое для ограниченного количества пользователей. Главная цель — получить отзывы клиентов о продукте и внести соответствующие изменения.

8. Классификация в зависимости от целей тестирования:
- Функциональное тестирование (functional testing) — направлено на проверку корректности работы функциональности приложения.
- Нефункциональное тестирование (non-functional testing) — тестирование атрибутов компонента или системы, не относящихся к функциональности.
    - Тестирование производительности (performance testing) — определение стабильности и потребления ресурсов в условиях различных сценариев использования и нагрузок.
    - Нагрузочное тестирование (load testing) — определение или сбор показателей производительности и времени отклика программно-технической системы или устройства в ответ на внешний запрос с целью установления соответствия требованиям, предъявляемым к данной системе (устройству).
    - Тестирование масштабируемости (scalability testing) — тестирование, которое измеряет производительность сети или системы, когда количество пользовательских запросов увеличивается или уменьшается.
    - Стрессовое тестирование (stress testing) — тип тестирования направленный для проверки, как система обращается с нарастающей нагрузкой (количеством одновременных пользователей).
    - Инсталляционное тестирование (installation testing) — тестирование, направленное на проверку успешной установки и настройки, обновления или удаления приложения.
    - Тестирование интерфейса (GUI/UI testing) — проверка требований к пользовательскому интерфейсу.
    - Тестирование удобства использования (usability testing) — это метод тестирования, направленный на установление степени удобства использования, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий.
    - Тестирование локализации (localization testing) — проверка адаптации программного обеспечения для определенной аудитории в соответствии с ее культурными особенностями.
    - Тестирование безопасности (security testing) — это стратегия тестирования, используемая для проверки безопасности системы, а также для анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным.
    - Регрессионное тестирование (regression testing) — тестирование уже проверенной ранее функциональности после внесения изменений в код приложения, для уверенности в том, что эти изменения не внесли ошибки в областях, которые не подверглись изменениям.
    - Повторное/подтверждающее тестирование (re-testing/confirmation testing) — тестирование, во время которого исполняются тестовые сценарии, выявившие ошибки во время последнего запуска, для подтверждения успешности исправления этих ошибок.




                            AGILE
Это методология (философия) управления разработкой, подчиняющаяся определеным принципам, озвученным в манифесте.                           
2001 год, США, штат Юта, группа из 17 разработчиков и глыб индустрии собралась вместе и родила AGILE манифест:

Люди и их взаимодействие важнее процессов и инструментов.
Работающий продукт важнее исчерпывающей документации.
Сотрудничество с заказчиком важнее согласования условий контракта.
Готовность к изменениям важнее следования плану.

                            SCRUM

Scrum — это методика гибкого управления проектами, помогающая командам структурировать работу и управлять ею на основе определенного набора ценностей, принципов и практик. Agile это философия, а scrum - это практическая методика работы.

Состав scrum-команды предполагает три конкретные роли: владелец продукта, scrum-мастер и команда разработчиков
Владелец продукта:
- они составляют бэклог продукта и управляют им., ПРИОРИТИЗИРУЕТ бэклог
- они тесно сотрудничают с руководством компании и командой, сообщая каждому участнику значение рабочих задач в бэклоге продукта.
- они дают команде понятные указания, чтобы ее участники знали, какие возможности поставить следующими.
- они решают, когда поставить продукт, стремясь делать это как можно чаще.
Scrum-мастер: (это может быть один человек - PM)
    Scrum-мастера следят за применением принципов Scrum в своих командах. Они обучают команды, владельцев продуктов и остальную компанию тонкостям scrum-процесса и стараются оптимизировать применение этой практики.
Команда разработчиков:
    Чтобы определить размер команды, можно обратиться к известному «правилу двух пицц», которое сформулировал глава Amazon Джефф Безос: в команде должно быть столько участников, чтобы им хватало двух пицц. То есть 5-7чел.
    Все участники команды помогают друг другу, чтобы успешно завершить спринт.

                        Артефакты Scrum

Артефакты Scrum — это важная информация, используемая scrum-командой для описания продукта и работ, которые необходимо выполнить для его создания. В Scrum есть три артефакта: бэклог продукта, бэклог спринта и инкремент с вашими критериями готовности. Это три константы, над которыми scrum-команда должна размышлять во время спринтов и с течением времени.    

Бэклог продукта — это главный список задач, которые необходимо выполнить. Его ведет владелец либо менеджер продукта. Это постоянно меняющийся перечень функциональных возможностей, требований, улучшений и исправлений, из которого берутся задачи для бэклога спринта. По сути, это список задач команды. Владелец продукта регулярно просматривает бэклог продукта, меняет в нем приоритеты и поддерживает его актуальность по мере появления новой информации или изменений на рынке, в связи с которыми отдельные задачи утрачивают смысл или возникают новые способы решения проблем.

Бэклог спринта — это список рабочих задач, пользовательских историй или исправлений багов, отобранных командой разработчиков для реализации в текущем цикле спринта. Перед каждым спринтом проводится собрание по планированию спринта (его мы обсудим далее в статье), на котором команда выбирает, какие задачи из бэклога продукта нужно выполнить в рамках спринта. Бэклог спринта может не быть фиксированным и может меняться по ходу спринта. Однако ничто не должно мешать достижению основной цели спринта — того, чего команда хочет добиться за текущий спринт.

Инкремент (или цель спринта) — это готовый к использованию конечный продукт по итогам спринта. В компании Atlassian принято представлять инкремент на демонстрации в конце спринта, на которой команда показывает, что она сделала за спринт.

Перечислим основные собрания, в которых может принять участие команда Scrum:

- Организация бэклога. За это мероприятие, также известное как ведение бэклога, несет ответственность владелец продукта

- Планирование спринта. На этом собрании команда разработчиков под руководством scrum-мастера планирует работу (объем спринта), которую необходимо выполнить в течение текущего спринта. В конце собрания по планированию каждый участник команды Scrum должен четко представлять, какие задачи можно выполнить за спринт и как поставить инкремент.Тут происходит покер планирование в story points.

- Спринт. Спринт — это фактический промежуток времени, в течение которого команда Scrum совместно работает над созданием готового инкремента. Как правило, спринт длится две недели, хотя некоторым командам проще спланировать объем спринта на одну неделю или поставить инкремент, обладающий достаточной ценностью, за месяц. В течение этого периода владелец продукта и команда разработчиков могут пересмотреть объем спринта, если это необходимо. Это и есть ключ к пониманию эмпирической сути Scrum.
- Ежедневное scrum-совещание, или стендап (дейлик). Это очень быстрое ежедневное совещание, которое проводится в одно и то же время (обычно утром) в стиле «коротко и по делу». Многие команды стараются уложиться в 15 минут, однако это лишь рекомендация.
Стендап — подходящее время сообщить обо всем, что мешает вам достичь цели спринта, в том числе о блокерах.
Чаще всего в рамках стендапа каждому участнику команды предлагается ответить на следующие три вопроса, связанные с достижением цели спринта:
• Что мне удалось сделать вчера?
• Что я планирую сделать сегодня?
• Может ли мне что-то помешать?

- Обзор итогов спринта (демо). В конце спринта команда собирается для просмотра демонстрации инкремента (или для его изучения) в неформальной обстановке. Разработчики представляют заинтересованным сторонам и коллегам завершенные рабочие задачи из бэклога, чтобы собрать отзывы. Владелец продукта решает, стоит ли выпускать инкремент, хотя в большинстве случаев команда получает зеленый свет.

- Ретроспектива спринта. Ретроспектива проводится, чтобы команда зафиксировала и обсудила все успехи и неудачи спринта, проекта, участников и их взаимоотношений, инструментов или даже определенных собраний. Цель ретроспективы — создать условия, чтобы команда могла уделить внимание всему, что удалось и что нужно улучшить в следующий раз, и не зацикливалась на неудачах.

                        Тестовая документация

Тест-план (Test Plan) представляет собой документ, в котором описан весь объем работ по тестированию, начиная с определения объекта тестирования и стратегии, заканчивая расписанием, критериями начала и окончания тестирования, а также необходимым оборудованием, специализированными знаниями и анализом рисков с возможными путями их разрешения.

Что включает в себя тест-план:

Название:
Объект тестирования: Полное описание того, что будет тестироваться. Это может быть приложение, веб-сайт, программное обеспечение и другие компоненты.
Стратегия тестирования: Определяет методы и подход к тестированию, включая ресурсы и время, необходимые для каждой фазы тестирования.
Тест-процедуры: Подробные инструкции, описывающие шаги для настройки, выполнения и оценки результатов теста.
Критерии начала и окончания тестирования: Условия, которые должны быть выполнены, чтобы начать и завершить тестирование. Они определяют готовность продукта к релизу.
Ресурсы для тестирования: Определяют необходимые ресурсы, включая персонал, среды тестирования, оборудование и инструменты.
Предварительные условия: Описывают состояние системы и ее окружение, которые необходимы для успешного тестирования.
Оценка рисков: Идентификация потенциальных проблем и способы их устранения для обеспечения успешного завершения тестирования.

Этот документ помогает всем участникам тестирования иметь общее представление о целях, процессе и требованиях для достижения успешного завершения тестирования продукта.

Тест-кейс

Тест-кейс (Test case) — пошаговое описание действий, которые нужно произвести для проверки какой-либо функции ПО.
**КАЖДЫЙ ТЕСТ-КЕЙС АТОМАРЕН И ПРОВЕРЯЕТ ТОЛЬКО 1 ДЕЙСТВИЕ.**
Простыми словами, это алгоритм, по которому тестировщик должен пройти (смоделировать поведение пользователя), чтобы проверить работоспособность определенного куска кода.

ID теста: 001
Название: Проверка входа на сайт с корректной парой логин/пароль.
Предусловия: Нет.
Шаги выполнения:	
    1. Откройте страницу сайта.
    2. На сайте вверху справа нажмите кнопку «Войти», дождитесь появления формы.
    3. В поле «Логин» введите «Тестеры», а в поле «Пароль» введите «NeverSleep», затем ниже нажмите кнопку «Войти».
Ожидаемый результат: На экране отображается профиль (личный кабинет) пользователя «Тестеры».
Постусловие: Нажать кнопку «Выход», чтобы выйти из системы.

Виды тест-кейсов:
- положительный
- орицательные
- деструктивные





                        DEV TOOLS
https://www.youtube.com/playlist?list=PLoZfdp36DZcqq6PoJJVHlS_c_1G89bkh7 - курс по тестированию

В Хроме (так как 90% людей пользуются браузерами на основе движка Blink)

Движки рендеринга страниц:
Blink (Chromium)
    Используется в браузерах Google Chrome, Microsoft Edge (до эого использовал собственный EdgeHTML, в 2020 перешел на Блинк) (версия на основе проекта Chromium), Opera.
    Разработан компанией Google и основан на проекте Chromium. Является forkом Apple WebKit
WebKit
    Используется в браузере Safari на устройствах Apple (macOS, iOS).
    Разработан компанией Apple на базе открытого проекта WebKit.
Gecko
    Используется в браузере Mozilla Firefox, TOR
    Разработан Фондом Mozilla.

CTRL + SHIFT + P - команданая строка
CTRL + SHIFT + K - открыть консоль в браузере
document.getElementsByTagName("video")[0].playbackRate = 2.25; - можно установить скорость видео введя это в консоли

