**Тестирование программного обеспечения (Software Testing)** — проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённым образом.

**Цель тестирования** — проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи программы.

Для чего мы тестируем:
- проверка соответствия требованиям (ожидание - реальность)
- для обнаружения проблем на ранних этапах разработки (или при анализе требований от бизнес аналитика и системного аналитика)
- обнаружение вариантов использования не по прямому назначению
- повышение лояльности клиента к компании и продукту (любой негатив влияет на это)

                    QA/QC/Testing

**Обеспечение качества (QA — Quality Assurance)** и **контроль качества (QC — Quality Control)**
— эти термины похожи на взаимозаменяемые, но разница между обеспечением качества и контролем качества все-таки есть, хоть на практике процессы и имеют некоторую схожесть.

QA (Quality Assurance) — Обеспечение качества продукта — изучение возможностей по изменению и улучшению процесса разработки, улучшению коммуникаций в команде, где тестирование является только одним из аспектов обеспечения качества.
- проверка требований к ПО
- оценка рисков (какие могут возникнуть проблемы, что может пойти не так)
- планирование как улучшить качество продукта
- подготовка тестовой документации, тестового окружения
- тестирование
- анализ результатов тестирования

QC (Quality Control) — Контроль качества продукта — анализ результатов тестирования и качества новых версий выпускаемого продукта.
- проверка насколько ПО готово к релизу
- проверка соответствия требований и качества

Testing (тестирование) - прохождение по шагам по готовой тестовой документации, где уже есть ОР и мы лишь выставляем ФР

Принципы тестирования:
1. Тестирование демонстрирует наличие дефектов (благодаря чему мы можем снизить вероятность наличия деефектов, но не гарантирует их полного отсутствия)
2. Исчерпывающее тестирование не возможно (полное тестирование с использованием всех входных комбинаций и предусловий невоможно, за искл нек случаев)
3. Раннее тестирование (начинать тестирование при разработке ПО надо начинать как можно раньше)
4. Скопление дефектов (большая часть багов находится в ограниченном количестве модулей)
5. Парадокс Пестицида - если повторять одни и те же тесты снова и снова, то в какой-то момент этот набор тестов перестает выявлять новые баги
6. Тестирование зависит от контекста (например банковкое приложение тестируется иначе чем новостной портал)
7. Заблуждение об отсутствии ошибок (отсутствие багов, не всегда значит готовность ПО к релизу, система должна быть удобна и удовлетворять потребности пользователей)

                    Верификация и валидация

Верификация - это процесс проверки того, что наще ПО соответствует спецификациям, требованиям, документации (которая сформулирована еще в начале). Делаем ли мы продукт правильно?

Валидация - это процесс проверки того, соответствует ли конечный продукт ожиданиям и потребностям пользователей. Делаем ли мы правильный продукт?

Пример с посадкой аэробуса A310 и закрылками/кручение колес.

Документация бывает 
- Проэктная (описывает весь проэкт включая временные рамки, бюджет, людской ресурс, оборудование, этапы, сроки, риски)
- Продуктовая (это техническая спецификация, архитектура, взаимодействие компонетнов, руководсво пользователя, руководсво админа, API документация, руководсво по тестирования и развертыванию, FAQ )

                    Tребования

Требования - это спецификация (описание) того, что должно быть реализовано.
Без технических деталей

Атрибуты требований:
1 Полнота — в требовании должна содержаться вся необходимая для реализации функциональности информация.
8 Модифицируемость — в каждое требование можно внести изменение.
2 Корректность — точное описание разрабатываемого функционала.
3 Недвусмысленность — требование должно содержать однозначные формулировки.
4 Непротиворечивость — требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам.
5 Проверяемость — формулировка требований таким образом, чтобы можно было выставить однозначный вердикт, выполнено все в соответствии с требованиями или нет.
6 Приоритетность — у каждого требования должен быть приоритет(количественная оценка степени значимости требования). Этот атрибут позволит грамотно управлять ресурсами на проекте.
7 Атомарность — требование нельзя разбить на отдельные части без потери деталей.
9 Прослеживаемость — каждое требование должно иметь уникальный идентификатор, по которому на него можно сослаться.

                        SDLC

SDLC (Software Development Life Cycle) - это жизненный цикл разработки программного обеспечения. Он представляет собой структурированный процесс, состоящий из различных фаз и этапов, которые выполняются при создании программного продукта.

1 Анализ и сбор требований: на этом этапе происходит определение и сбор требований к программному продукту. Проводится исследование, выявляются потребности пользователей и определяются функциональные и нефункциональные требования.
2 Проектирование: на этом этапе разрабатывается архитектура и дизайн программного продукта. Определяются компоненты системы, их взаимосвязи и интерфейсы.
3 Разработка: на этом этапе происходит непосредственная реализация программного продукта. Программисты пишут код, создают функциональность и выполняют тестирование единиц кода.
4 Тестирование: на этом этапе проводится тестирование программного продукта с целью выявления ошибок, дефектов и проверки его соответствия требованиям. Включает в себя функциональное тестирование, интеграционное тестирование, системное тестирование и другие виды тестирования.
5 Развёртывание: на этом этапе программный продукт готовится к выпуску и установке на целевой среде. Включает в себя подготовку документации, инсталляцию, настройку и обучение пользователей.
6 Эксплуатация и поддержка: после развёртывания программного продукта происходит его эксплуатация, поддержка и обновление. Ведется мониторинг работы системы, исправление ошибок и добавление новой функциональности.

                        STLC


STLC (Software Testing Life Cycle) - это жизненный цикл тестирования программного обеспечения. Он представляет собой структурированный процесс, состоящий из различных фаз и этапов, которые выполняются при проведении тестирования программного продукта.

1. Планирование: на этом этапе определяются цели тестирования, разрабатывается план тестирования и определяются ресурсы, необходимые для выполнения тестов.
2. Анализ требований и создание тестовой документации: на этом этапе изучаются требования к программному продукту и создается тестовая документация, включающая тестовые случаи, тестовые сценарии и другие артефакты.
3 Дизайн тестов: на этом этапе разрабатывается стратегия тестирования и определяются методы, подходы и техники, которые будут использоваться для проведения тестов. Создаются тестовые случаи и сценарии на основе требований и анализа продукта.
4 Подготовка к выполнению тестов: на этом этапе создается тестовая среда, включающая необходимые инструменты и данные для проведения тестов. Также выполняется подготовка тестовых сценариев и проверка настроек тестовой среды.
5 Выполнение тестов: на этом этапе проводятся тестирование по определенным тестовым случаям и сценариям. Результаты тестов регистрируются, ошибки и дефекты отслеживаются и отчеты о тестировании создаются.
6 Анализ результатов тестирования: на этом этапе происходит анализ результатов тестирования, выявление и регистрация дефектов. Оценивается качество продукта и принимаются решения о его готовности к выпуску.
7 Завершение: на этом этапе подводятся итоги тестирования, создается финальный отчет о выполненном тестировании, проводится оценка процесса тестирования и выявление возможных улучшений.

                        Severity vs Priority

    Severity (серьезность) - показывает степень ущерба, который наносится проекту существованием дефекта. Severity выставляется тестировщиком.
Стоит учесть что Серьезность применяется в основном к баг-репортам

Блокирующий (S1 – Blocker) - тестирование значительной части функциональности вообще недоступно. Блокирующая ошибка, приводящая приложение в нерабочее состояние, в результате которого дальнейшая работа с тестируемой системой или ее ключевыми функциями становится невозможна.

Критический (S2 – Critical) - критическая ошибка, неправильно работающая ключевая бизнес-логика, дыра в системе безопасности, проблема, приведшая к временному падению сервера или приводящая в нерабочее состояние некоторую часть системы, то есть не работает важная часть одной какой-либо функции либо не работает значительная часть, но имеется workaround (обходной путь/другие входные точки), позволяющий продолжить тестирование.

Значительный (S3 – Major) - не работает важная часть одной какой-либо функции/бизнес-логики, но при выполнении специфических условий, либо есть workaround, позволяющий продолжить ее тестирование либо не работает не очень значительная часть какой-либо функции. Также относится к дефектам с высокими visibility – обычно не сильно влияющие на функциональность дефекты дизайна, которые, однако, сразу бросаются в глаза.

Незначительный (S4 – Minor) - часто ошибки GUI, которые не влияют на функциональность, но портят юзабилити или внешний вид. Также незначительные функциональные дефекты, либо которые воспроизводятся на определенном устройстве.

Тривиальный (S5 – Trivial) - почти всегда дефекты на GUI — опечатки в тексте, несоответствие шрифта и оттенка и т.п., либо плохо воспроизводимая ошибка, не касающаяся бизнес-логики, проблема сторонних библиотек или сервисов, проблема, не оказывающая никакого влияния на общее качество продукта

    Срочность (priority) - показывает, как быстро дефект должен быть устранён. Priority выставляется менеджером, тимлидом или заказчиком

P1 Высокий (High) - Критическая для проекта ошибка. Должна быть исправлена как можно быстрее.
P2 Средний (Medium) - Не критичная для проекта ошибка, однако требует обязательного решения.
P3 Низкий (Low) - Наличие данной ошибки не является критичным и не требует срочного решения. Может быть исправлена, когда у команды появится время на ее устранение.

                   Пирамида тестирования

Это группировка тестов по уровню детализации и назначению
4 уровня: (снизу вверх)
   
    - Модульное тестирование (юнит-тестирование) компонентный уровень
Всегда автоматизируют, им обычно занимается разраб, этих тестов больше, они выполняются быстрее всех и требуют меньше ресурсов, и они не зависят от других модулей (н-р в калькуляторе тестируем функцию сложение, которая не зависит от умножения)
Тут используется метод белого ящика
Unit-тесты занимают основное место в пирамиде, так как они:
1 Наименее затратные по времени и ресурсам.
2 Проверяют отдельные компоненты, что позволяет быстро обнаруживать и устранять ошибки в них.
Модульное тестировпнре подращумевает доступ к коду и его понимание. Обычный тестер не делает можкльное тестировпние, так как не шарит в коде. Но не надо путать модульное тестирование как уровень и темтирование отдельных модулей. Мы можем тестировать отдельные модули. 

    - Интеграционное тестирование
Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в английских статьях называют service test или API test.
Компоненты ПО или системы взаимодействуют с тестируемым модулем с помощью интерфейсов. Это проверки API, работы сервисов (проверка логов на сервере, записи в БД) и т.п. Отдельно отмечу, что в интеграционном тестировании, выполняются как функциональные (проверка по ТЗ), так и нефункциональные проверки (нагрузка на связку компонент). На этом уровне используется либо серый, либо черный ящик.
Имеют более высокий уровень абстракции и сложности, чем Unit-тесты, поэтому их меньше, но они все еще затратны.

В интеграционном тестировании есть 3 основных способа тестирования:
    1 Снизу вверх (Bottom Up Integration): все мелкие части модуля собираются в один модуль и тестируются. Далее собираются следующие мелкие модули в один большой и тестируется с предыдущим и т.д. Например, функция публикации фото в соц. профиле состоит из 2 модулей: загрузчик и публикатор. Загрузчик, в свою очередь, состоит из модуля компрессии и отправки на сервер. Публикатор состоит из верификатора (проверяет подлинность) и управления доступом к фотографии. В интеграционном тестировании соберем модули загрузчика и проверим, потом соберем модули публикатора, проверим и протестируем взаимодействие загрузчика и публикатор.

    2 Сверху вниз (Top Down Integration): сначала проверяем работу крупных модулей, спускаясь ниже добавляем модули уровнем ниже. На этапе проверки уровней выше данные, необходимые от уровней ниже, симулируются.Например, проверяем работу загрузчика и публикатора. Руками (создаем функцию-заглушку) передаем от загрузчика публикатору фото, которое якобы было обработано компрессором.

    3 Большой взрыв ("Big Bang" Integration): собираем все реализованные модули всех уровней, интегрируем в систему и тестируем. Если что-то не работает или недоработали, то фиксим или дорабатываем.

    - Системное тестирование
Системный уровень проверят взаимодействие тестируемого ПО с системой по функциональным и нефункциональным требованиям.
Важно тестировать на максимально приближенном окружении, которое будет у конечного пользователя.
На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.
На этом уровне используют черный ящик. Интеграционный уровень позволяет верифицировать требования (проверить соответствие ПО прописанным требованиям).
    
    - Приемочное тестирование
Также часто называют E2E тестами (End-2-End) или сквозными. На этом уровне происходит валидация требований (проверка работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне).
Проверка требований производится на наборе приемочных тестов. Они разрабатываются на основе требований и возможных способах использования ПО.
Отмечу, что приемочные тесты проводят, когда (1) продукт достиг необходимо уровня качества и (2) заказчик ПО ознакомлен с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).
Проверяют приложение на уровне пользователя, оценивая его работу в реальных условиях.
Более медленные и затратные, так как они эмулируют действия пользователя на более высоком уровне.

                        Техника тест-дизайна 

Техника тест-дизайна - это систематический подход к планированию, созданию и выбору тестовых случаев и данных для тестирования программного обеспечения с использованием определенных методов и стратегий

Техника тест-дизайна - это набор методов и инструментов, используемых для разработки тестовых случаев на основе заранее определенных критериев и анализа требований. Она позволяет структурировать и оптимизировать процесс тестирования, обеспечивая максимальное покрытие функциональности и возможных сценариев использования программного продукта.

1 Увеличение покрытия тестирования: Техники тест-дизайна помогают создавать тесты, которые охватывают различные аспекты программного обеспечения, включая различные варианты использования и возможные ошибки.
2 Эффективное использование ресурсов: Позволяют оптимизировать количество тестовых случаев и ресурсы, необходимые для тестирования, снижая издержки и ускоряя процесс разработки.
3 Повышение качества программного обеспечения: Создание более полного и эффективного плана тестирования способствует выявлению ошибок и недочетов в ранние стадии разработки, что помогает улучшить качество программы и снизить вероятность возникновения проблем после выпуска в эксплуатацию.

    Эквивалентное разделение

Эквивалентное разделение подразумевает разбиение тестовых данных на классы по какому-то признаку. 
Если мы выбираем в качестве техники тест-дизайна эквивалентное разделение, это означает, что мы будем тестировать только несколько значений из каждого класса элементов. Помните, что это не гарантирует отсутствия ошибок в остальных значениях, не охваченных тестами. Мы лишь предполагаем, что использование нескольких элементов из каждой группы будет достаточно показательным.
Эквивалентное разделение — хорошее решение для случаев, когда вы имеете дело с большим объемом входящих данных или множеством одинаковых вариантов ввода. В противном случае, возможно, имеет смысл более тщательно охватить продукт тестами.

    Анализ граничных значений

Анализ граничных значений в чем-то похож на эквивалентное разделение. Можно даже сказать, что оно лежит в основе эквивалентном разбиении. Но есть некоторые отличия.
При анализе граничных значений мы тоже группируем данные по эквивалентным классам, но проверяем не значения из определенного класса, а граничные значения — те, которые находятся на «границах» классов.
Кейс с тестированием мед софта (веб-сайта) для изучения депоессии путем сканировния мозга. 
    
    Переход состояний

Диаграмма перехода состояний визуализирует состояния программы в разные периоды времени и на разных этапах использования. Визуальную информацию воспринимать проще, чем текст. Таким образом, техника перехода состояний позволяет быстрее получить максимальное тестовое покрытие.
Допустим, мы тестируем систему, которая предлагает ограниченное количество попыток ввести правильный пароль. Если пользователь не введет правильный пароль 3 раза, система блокирует доступ (временно или постоянно).

    Попарное тестирование

Попарное тестирование основано на математических алгоритмах, а именно на комбинаторике. Оно позволяет создавать уникальные пары и тестировать огромное количество поступающих данных в разных сочетаниях, но расчеты могут быть сложными.
Чтобы охватить тестовыми сценариями максимум фич и при этом потратить минимальное время на тестирование, нужно правильно сопоставлять данные, комбинируя пары определенным образом на основе расчетов.

	Предугадывание ошибок

На основании опыта мы уже знаем гле могут возникнуть ошибки и соответсвено составояем тест кейсы и использкем в них те или инве входные данные.
- ввод неверных параметров (адрес электронной почты вместо номера телефона и т.д.)
- загрузка файлов, превышающих максимально допустимый размер