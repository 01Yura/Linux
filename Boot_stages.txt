FIRMWARE STAGE
1. Подача питания на комп (кновка включения)
2. Включается прошивка (firmware) BIOS (basic input/output system) или UEFI (Unified Extensible Firmware Interface) Это микросхема, расположенная на материнской плате. ПОсле включения процессор читает код BIOS из микросхемы ПЗУ (ROM), записывает его в RAM и происходит его выполнение.
3. POST (power-on self test). Инициализируется оборудование (что есть вообще), тестируется конфигурация оборудования, чтобы понять что аппаратное обеспечение работает правильно. 
NOTE! CMOS (Complementary Metal-Oxide-Semiconductor)- это оперативная память небольшого объема (обычно 256 байт), входит в сотав южного моста, питается от небольшой  батарейки, расположенной на материнской плате. В этой памяти сохраняются различные настройки и сведения о конфигурации, которые использует в своей работе BIOS.
Пользователь может получить доступ к некоторым из них, зайдя в режим "настроек BIOS" или BIOS Setup. Для этого нужно после включения ноутбука нажать на клавиатуре определенную клавишу
Таким образом BIOS хранится в энергонезависимой памяти и служит для запуска коипьютера. Одним из режимов его работы является режим настроек. Эти настройки, а так же другие, недоступные пользователю, хранятся в памяти CMOS, которая запитана от батарейки. От этой же батарейки идут часы.
Если POST прошел успешно, то:
4. BIOS, согласно настройкам анализирует какие есть утройства хранения информации и на каком соответственно искать MBR (Master Boot Record) или GPT (GUID Partition Table, есть в начале и в конце для надежности). Находится на первом секторе диска и равна 512 байтам (состоит из загрузчика - first stage bootloader (код загрузки или bootstrap code) размером 446 байт и таблицы разделов размером 64 байт (по 16 байт на раздел, таким образом при использовании MBR можно сделать только 4 основных(primary, активных) раздела, на которых можно разместить ОС) и 2 байта для цифровой подписи. Последние два байта MBR называются сигнатурой. Значение этих 2х байтов должно быть 55h AAh. В случае, если это не так, запись считается некорректной. ).
5. Далее MBR смотрит какие есть разделы на данном диске и какой раздел помечен как активный, чтобы считать его по умолчанию. Передает эстафету загрузчику этого активного раздела (PBR, partition boot record), который например хранится по адресу boot/grub, и уже этот загрузчик считывает свой конфиг файл grub.cfg и берет оттуда данные что и куда грузить (ядро, корень, опции и инитрд)
NOTE! Если загрузчик может полностью уместиться в первые 512 байт основной загрузочной записи и запустить операционную систему с этим ограниченным объемом кода, он считается одноступенчатым загрузчиком

Если заменить BIOS на UEFI, то отпадает необходимость в загрузчике в MBR. При включении UEFI ищет раздел EFI System Partition и загружает оттуда bootx64.efi или grubx64.efi, а это запускает GRUB.

BOOTLOADER STAGE

SECOND BOOTLOADER
6. Теперь считывается Second stage bootloader из PBR активного раздела. Представляет собой исполняемые файлы и конфигурац файлы.
Загрузчики LInux:
- GRUB (GRAND Unified Bootloader)
- GRUB 2
- Lilo (Linux Loader)
- Bootx
- Sparc Improved bootLOader (SILO)
- Yet Another BOOTloader (YABOOT)
- Также возможна загрузка из сети через Preboot Execution Environment (PXE). В системе PXE совместимая материнская плата и сетевая карта обладают достаточным интеллектом, чтобы получить адрес из сети и использовать протокол TFTP (Trivial File Transfer Protocol) для загрузки специального загрузчика с сервера.

Загрузчик знает где лежит ядро, знает его параметры загрузки (можно настроить), грузит ядро в RAM, грузит Initial Ram disk (initrd - содержит конфиг файлы и модули для загрузки ядра)
Можно загрузить ядро в режиме обслуживания

настройки GRUB2 лежат в /boot/grub/grub.cfg

KERNEL STAGE
7. Ядро (kernel)
Находится в папке /boot/vmlinuz-x.y.z.-a 
Слово - generic значит общий образ, без лишних модулей.
В этой папке может хранится много ядер
Вообще ядро представлено остовом - vmlinuz (без драйверов, то есть без возможности использования оборудования) и несколькими модулями. Но вместо этих модулей вместе с ядром загружается RAM-диск (архив с некоторым количеством этих модулей) - initramd или initramfs.
Ядро должно инициализировать все аппаратные драйверы и смонтировать корневую / файловую систему для следующего и запутить первый процесс - init.
Однако возможно, что корневая файловая система существует на устройстве, которое ядро не знает, как поддерживать. Как минимум ядру нужны наприпер модули scsi и ext4. Но где их взять? Решением этой проблемы является initrd RAM-диска. Драйверы ядра, необходимые для продолжения загрузки, встроены в псевдо-файловую систему, которая хранится рядом с самим ядром в /boot в файле initrd.img. Ядро загружается, монтирует initrd, таким образом монтируется псевдо-файловая система (мини корневая файловая система, на которой ей все то же что и на обычной), которая загружает драйверы внутрь, а затем уже можно смонтировать реальную корневую файловую систему, используя новые драйверы. Это позволяет легко добавлять драйверы в ядро, а ядро монтировать корневую файловую систему практически на любом оборудовании для хранения данных, даже если оно подключено к сети.
ядро способно смонтировать в самом себе необходимую корневую файловую систему, однако для этого подобному ядру придётся удерживать все обсуждавшиеся исполняемые файлы, библиотеки поддержки, файлы настройки и т.п. в своём файле vmlinuz. Это создаст большое число проблем.

Это испортит основной повод исполняемого самого файла ядра.
Исполняемый файл такого ядра будет гигантским в размере. Чем большим размером будет обладать исполняемый файл, тем сложнее его сопровождение.
Такой громадный исполняемый файл сложный в поддержке, обновлении, совместном использовании и обработке в серверах (с точки зрения пакетов RPM).
Этот подход не будет следовать правилу KISS (keep it simple, stupid - делай проще, тупица).
                
							INIT STAGE
Существует несколько стилей процусса init
- SystemV или SysV или SysVinit(родительский процесс инициализации системы на одном из заданных уровне запуска (runlevel) Их всего 6шт)
- UpStart (на основе отслеживания событий. Если что то не запустилось или упало, то повторно)
- Systemd (в ускоренном режиме, засчет параллельного запуска)
Даже если ваша система использует Systemd или Upstart в качестве замены традиционного процесса init, обе замены используют исполняемый файл с именем init по пути /sbin/init --> /lib/systemd/systemd
В системах systemd файл /sbin/init является символической ссылкой на файл /lib/systemd/systemd в целях совместимости.
                 
                 INIT (System V)
Если используется традиционная система init(SystemV), то файл /etc/inittab используется для определения того, какие скрипты будут запускаться для запуска служб системы

Файл inittab указывает на другие скрипты, которые выполняют эту работу, обычно хранящиеся в каталоге 
/etc/init.d (тут хранятся все скрипты)

id:3:initdefault: - данная строка в файле inittab указывает runlevel по умолчанию. Его можно изменить прямо тут.

/etc/ rc0.d -> rc.d/rc0.d
      rc1.d -> rc.d/rc1.d    и т.д.
      Здесь хранятся скрипты для каждого runlevelа в виде некоторых ссылок на скрипты в папке /etc/init.d (где хранятся все скрипты)
например: K15httpd -> ../init.d/httpd
          S55sshd -> ../init.d/sshd
Начинается с буквы Kill или Start и цифры, указывающий поряд вкл или откл.

runlevel - посмотреть текщий уровень выполнения
who -r - тоже
init НОМЕР - сменить runlevel немедленно
telinit НОМЕР - аналогично

               SYSTEMD

Unit - модули, которыми оперирует системди
Они бывают:     .service
                .mount
                .device
                .socket

 /usr/lib/systemd - директория с юнитами по умолчанию
В ней есть помимо всего две папки 
system - с юнитами для системы
user - с юнитами для пользователя
 /etc/systemd - директория с юнитами, которыми может управлять админ и файлами настройки (как /etc/inittab в SystemV)

Если традиционный init был заменен на Systemd, то файлы в каталоге /etc/systemd используются для запуска системы.

Systemd монтирует файловую систему согласно файлу /etc/fstab. В нем написано что и куда монтировать. Читает остальные файлы конфигурации из /etc. И полностью загружает систему, в том числе те драйвера (видеокарта напрмаер), которые были не нужны ядру на начальном этапе загрузки.
 pstree - посмотреть дерево процессов

systemctl - команда для управления systemd. Расшифровывается как System control

systemctl list-units - показывает все запущенные юниты
systemctl --failed - юниты которые по какой то причине не запустились
systemctl list-units --type=service - показать только сервисы
systemctl list-units --type=target - какие таргеты запущены. Так можно определить runlevel. Ну или запустить команду runlevel

systemctl start СЕРВИС(ДЕМОН)
          stop
          status 
systemctl -all - посмотреть все что работает

systemctl enable ДЕМОН - автозагрузка
          disable - отключить автозагрузку

systemctl isolate desired.target - чтобы сменить ранлевел так же как и командой runlevel
systemd.unit=desire.target - изменить ранлевел при загрузке, вписав его как параметр загрузки ядра
или
systemctl set-default -f multi-user.target - -f это форсировать, те перезаписать вмето того, который есть

systemctl hibernate/suspend/poweroff/reboot 

systemctl list-dependencies graphical.target

RUNLEVELS
0 - halt or shut off - poweroff.target
1 - single-user mode - rescue.target
2,4 - настраиваемые режимы - multi-user.target
3- normal - multi-user.target
5 - normal with graphical display - graphical.target
6 - restart - reboot.target

/usr/lib/systemd/system/default.target - место хранения default runlevel (который запускается по умолчанию). Это ссылка на target в этой же папке:
/usr/lib/systemd/system/default.target -> graphical.target


                UPSTART
/etc/init -  тут хранятся все jobs (файлы с расширением .conf) На лабораторных машинах netacad эта директория есть тока на centos

/etc/init.d - тоже хранятся службы

Если традиционная инициализация была заменена на Upstart, то для завершения init системы используются сценарии в файле /etc/init.d --> rc.d/init.d , в котором находятся скрипты

Для Upstart - runlevel по умолчанию хранится в переменной DEFAULT_RUNLEVEL 
                в /etc/init/rc-sysinit.conf

initctl - аналог systemctl в systemd

chkconfig --list НАЗВАНИЕ_ДЕМОНА - показывает что запускается, а что нет на всех уровнях
chkconfig on НАЗВАНИЕ_ДЕМОНА
chkconfig off НАЗВАНИЕ_ДЕМОНА

halt, poweroff, shutdown - выключть 
shutdown now
shutdown now "СООБЩЕНИЕ ДЛЯ ВСЕХ ПОЛЬЗОВАТЕЛЕЙ"
shutdown -r - перезагрузка
shutdown +10 - выключить через 10 мини
shutdown -h - halt

wall
echo -e "СООБЩЕНИЕ ВСЕМ" | wall - сообщение всем пользователям
wall file.txt
cat file.txt | wall 

etc/rc0-6.d - в этих папках расположены службы (демоны), а точнее символьные ссылки на сами демоны хранящиеся в etc/init.d/
Ссылки начинаются с буква S и цифры:
     S01ssh -> ../init.d/ssh

service sshd start/stop/status, 
    restart - stop and then start 
    reload - read and load configuration
    configtest - check the conf files to correctness



journalctl -f - события в режиме онлайн
journalctl _UID=0 - события пользователя


acpi - чтобы экономить батарею (показывает остаток заряда, температуру)

                  GRUB

https://ru.m.wikibooks.org/wiki/Grub_2

Восстановление GRUB при испорченном grub.cfg
если /boot находится на корневом разделе, а не на отдельном диске

1) Определяем какой раздел является корневым
ls - выводит разделы 
set root=(hd0,2) - присватваем переменной root значение (hd0,2) (тот раздел,где находится /boot/ядро+initrd)
ls / - если то что отображается является корневым разделом, то все хорошо, если нет, то присваиваем переменной root другой диск.
linux /boot/vmlinuz TAB ro root=/dev/sda2 - задаем местоположение ядра в директории /boot далее параметры ro-read only и root=реальный_корневой_раздел /, а именно куда монтируется ядро
initrd /boot/initrd TAB
boot
Загружаемся
grub-install /dev/sda - устанавливаем grub на диск, а не на раздел! (можно без этой команды)
update-grub - обновляем конфигурацию (появляется grub.cfg)

2) Смотрим какие есть разделы
ls
linux (hd0,gpt2)/ TAB - если появилась возможность ввести boot и тд, то раздел тот, поэтому продолжаем команду:
linux (hd0,gpt2)/boot/vmlinuz TAB root=/dev/sda2 (указываем реальный корень диска /)
initrd (hd0,gpt2)/boot/initrd TAB
boot
Загружаемся
grub-install /dev/sda - устанавливаем grub на диск, а не на раздел! (можно без этой команды)
update-grub - обновляем конфигурацию (появляется grub.cfg)


Восстановление GRUB при испорченном первом секторе


В данном случае ничего не загружается, просто черный экран

Загружаемся с live CD
Если разделы отображаются, то переходим к монтированию, если нет, то нужно восстановить таблицу разделов внутри MBR с помощью программы
testdisk (ее надо установить)

sudo mount /dev/sda5 /mnt - монтируем корень своего нерабочего linux в папку /mnt
sudo mount /dev/sda2 /mnt/boot - монтируем /boot раздел если он находится на другом разделе
sudo grub-install --root-directory=/mnt /dev/sda - теперь переходим собственно к установке grub2. Ключ "--root-directory" позволяет указать, что использовать в качестве корневой директории. Нам нужен корневой раздел нашей системы, который примонтирован в /mnt
umount /mnt/boot 
umount /mnt
reboot

Еще вариант 
Загружаемся с live CD
sudo mount /dev/sda5 /mnt - монтируем корень своего нерабочего linux в папку /mnt
sudo mount /dev/sda3 /mnt/boot - монтируем /boot раздел если он находится на другом разделе
sudo mount --bind /dev /mnt/dev - если система обращается к папке /dev, то она будет обращаться к папке /mnt/dev
sudo mount --bind /proc /mnt/proc
sudo mount --bind /sys /mnt/sys
sudo chroot /mnt - меняем корневую директорию live CD на корневую директорию нашего не работающего linux
grub-install /dev/sda
или
grub-install --recheck /dev/sda
или
grub-install --recheck --no-floppy /dev/sda
exit - выходим с корня в live CD
Отмонтируем все по очереди 
reboot


