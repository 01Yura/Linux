                 Лицензирование
https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg
https://ru.wikipedia.org/wiki/Linux_From_Scratch
https://ru.wikipedia.org/wiki/Unix-%D0%BF%D0%BE%D0%B4%D0%BE%D0%B1%D0%BD%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0

hostnamectl - версия ос, имя хоста, ядро, архитектура

                        NANO
Копирование в nano ctrl+shift+6, выделяем блок, alt+6(копируем), ctrl+U(вставляем)

Заменить дурацкий vi на нано при редактировании :
open your ~/.bashrc file:
nano ~/.bashrc

Add the following line:
export EDITOR=nano

Save and close
relogin



Linux - GPLv2

GNU General Public License v2
Цель GNU GPL — предоставить пользователю права копировать, модифицировать и распространять (в том числе на коммерческой основе) программы, а также гарантировать, что и пользователи всех производных программ получат вышеперечисленные права
Лицензируя работу на условиях GNU GPL, автор сохраняет за собой авторство
GNU GPL не позволяет включать программу в проприетарное ПО. Если данная программа является библиотекой, вероятно, лучшим будет разрешить проприетарному ПО линковаться с ней

GNU Lesser General Public License (LGPL)
Эта лицензия менее «свободна» и в основном используется для программных библиотек. LGPL не гарантирует конечному пользователю полную свободу использования программного обеспечения. Только свободу модификации для компонентов, лицензированных по LGPL, но не для каких-либо проприетарных компонентов.
Коммерческое ПО может линковаться с библиотекой, выпущенной под LGPL, и при этом оно не будет «заражено» GPL и может оставаться закрытым.
Это позволяет использовать свободные библиотеки в закрытом ПО, все преимущества свободной библиотеки сохраняются. Например, если компания сделает свое изменение в этой библиотеке, она будет обязана его опубликовать. Таким образом библиотека продолжает развиваться большими коммерческими компаниями, которые в то же время могут использовать ее в закрытых продуктах





ПЕРЕМЕННЫЕ (VARIABLES)
env - посмотреть только (environment) глобальные переменные 
env, declare -x, typeset -x или export -p - показывает глобальные переменные 
set - локальные и  глобальные и функции
название_переменной=значение
например name=yura
Локальные переменные (local or shell) пишутся с маленькой буквы
Глобальные переменные (enviromental or global) - с большой
export НП - сделать переменную глобальной
unset НП - удалить переменную
echo ${PATH} то же самое что и echo $PATH, просто скобки {} используются для визуального выделения и улучшения восприятия

Используя следующий синтаксис, команду env также можно использовать для временного задания переменной:
    env VARIABLE_NAME=TEMP_VALUE command
    env TZ=EST date

$PS1 - это переменная приглашения ввода (yura@yuraserver:~$)
Её можно переназначить.

PS1='\u@\h \w \$ ' - показывает имя пользователя, хоста, рабочий каталог и символ пиглашения $

После изменения файла bash.bashrc и тому подобных надо его перечитать командой source или просто "." Если вывода не будет, значит все норм. Если вывод есть, значит ошибка где-то.




type НК - показывает что за команда(встроенная в оболочку, алиас, или хранящаяся в одной из папок переменной $PATH программа). Кроме того показывает есть ли такая команда в системе вообще или нет.
type -a НК - показывает еще и путь до нее
which НК - показывает путь до программы (ищет в $PATH)
w - кто в системе 

            `` или ()

echo `date` или echo $(date) - одно и то же, команда в команде
touch file.$(date +%F).sh - создать файл с датой в имени

alias НА=комманда (если команда из нескольких слов, то в одинарных кавычках)
unalias НА - удалить псевдоним
\ls - знак \ перед командой выполнит данную команду, а не ее алиас

Функции (типа скрипта)
root@291417:~# my_report () {
> ls /home/yura/
> date
> echo "This is END"
> }
 Сначала прямо в коммандной строке пишешь любое название функции, ставишь в скобки (), затем ставишь фигурную скобку { и нажимаешь ENTER
 Появляется приглашение для ввода команд
 После ввода снова ставишь скобку }.
 Вызываешь функцию по ее названию

 report () { cd $1; echo "Document directory usage report" ; > /home/yura/report; date >> /home/yura/report; pwd >> /home/yura/report; du -sh . >> /home/yura/report;cd ~; }
 В данной функции при ее вызове можно указать путь к папке.

 lS() { ls -lrS $@; } - $@ это ссылка на любые аргументы, которые могут быть добавлены в функцию

 declare -f - показать все существующие функции
 unset НФ - удаляет функцию
 test -e $HOME/bin || mkdir $HOME/bin - проверить если существует директория , то тогда команда выполняется

  Например, следующий гибридный список И/ИЛИ может быть использован в сценарии, чтобы убедиться, что переменная search либо установлена в первый аргумент, передаваемый скрипту, либо в текущий рабочий каталог:

test $# -eq 0 && search=`pwd` || search=$1

#function showlog
function showlog() {
date > ./$1.txt;
last | grep $1 | tail -n $2 >> $1.txt;
}
Эта функция показает попытки входа (кол-во указывается в $2) для пользоватедя $1 с помощью команды last (ТОЛЬКО В CENTOS)

read –p "Please enter your name: " name - аргумент  -p позволяет выдать подсказку


Существует два типа файлов инициализации: global файлы инициализации, которые влияют на всех пользователей в системе, и local файлы инициализации, относящиеся к отдельному пользователю.

LOGIN SHELL (вход в систему)
/etc/profile ---> ~/.bash_profile ---> ~/.bashrc ---> /etc/bashrc

INTERACTIVE SHELL (запускаешь терминал)
~/.bashrc ---> /etc/bashrc

/etc/profile 	Этот файл может быть изменен только администратором и будет выполнен каждым пользователем, который войдет в систему. Администраторы используют этот файл для создания ключевых переменных среды, отображения сообщений пользователям при входе в систему и установки ключевых системных значений.
Он ищет в папке /etc файл bash.bashr или, если его нет, то bashc. И выполняет скрипты из папки profile.d

~/.bash_profile 	У каждого пользователя есть свой .bash_profile файл в домашнем каталоге. Назначение этого файла такое же, как и у файла //etc/profile, но наличие этого файла позволяет пользователю настроить оболочку по своему вкусу. Этот файл обычно используется для создания настраиваемых переменных среды. В CENTOS тут хранится $PATH.

В UBUNTU $PATH хранится в /etc/environment


~/.bashrc 	У каждого пользователя есть свой .bashrc в его домашнем каталоге. Целью этого файла является генерация элементов, которые должны быть созданы для каждой оболочки, таких как локальные переменные и псевдонимы.

/etc/bashrc 	Этот файл может повлиять на каждого пользователя системы. Только администратор может изменить этот файл. Как и в случае с .bashrc, этот файл предназначен для создания элементов, которые должны быть созданы для каждой оболочки, таких как локальные переменные и псевдонимы.


~/.bash_logout - выполняется при выходе пользователя из системы. Обычно просто очищается экран.

/etc/skel - тут хранятся все инициализауионные файлы, которые копируются в домашнюю директорию пользователя при его создании. 

В файлах оканчивающихся на RC хранятся псевдонимы и функции

              КАВЫЧКИ
Двойные кавычки позволяют сделать запрет интерпретации спец символов (glob characters (wildcards))
Одинарные кавычки запрещают все символы
\ - символ экранирования символа после черты
Обратные кавычки `` - позволяют написать команду в команде 
например:
sysadmin@localhost:~$ echo Today is `date`                         
Today is Mon Nov 4 03:40:04 UTC 2018
; - точка с запятой (semicolon), отделяет команды, которые выполняются последовательно вне зависимости от успешности предыдущей
&& - двойной амперсанд - действует как логическое И, команда выполняется только после успешного завершения предыдущей
|| - лгическое ИЛИ, вторая команда запускается, если первая несработала


              ПОИСК

man НК - открыть мануал по команде
в [] квадратных скобках в пункте Синопсис (примеры использования) указаны не обязательные аргументы
/ - символ для начала поиска, затем поисковое слово и Энтер
n and N - следующее совпадение и предыдущее совпадение

 По умолчанию справочные страницы состоят из девяти разделов:

   1 Общие командования
   2 Системные вызовы
   3 Библиотечные звонки
   4 Специальные файлы
   5 Форматы файлов и соглашения
   6 Игры
   7 Смешанный
   8 Команды системного администрирования
   9 Подпрограммы ядра

man -f passwd  -  позволяет найти в каких разделах есть инфа
sysadmin@localhost:~$ man -f passwd                            
passwd (5)           - the password file                              
passwd (1)           - change user password                           
passwd (1ssl)        - compute password hashes  

whatis НК- делает то же самое

arch - к какому семейству принадлнжит проц
lscpu - тоже о ЦП
free -m - о памяти в Мбайтах
free -s 10 - обновлять значения каждые 10 сек
lspci - компоненты , подключенные к компу
lsusb - все usb устройства
fdisk -l - инфа о дисках
 
/proc - содержит сведения о процессах
pstree - дерево родит и дочерн связей
ps --forest - строит дерево
ps -u имя_пользователя - показыват только процессы 
ps aux или ps -ef - все процессы
top - процессы в онлайне
    K - kill
    R - renice
ps -o pid,tty,time,%mem,cmd --sort %mem - выводит только определенные колонки и сортирует по памяти
tail /var/log/auth.log - попытки авторизации


                                СЕТИ

/etc/nsswitch.conf - в этом файле инфа в каком порядке искать соответствие имя-ip фдресс
    hosts:          files dns = снаяала в файле hosts потом в DNS
/etc/hosts
    Файл, содержащий таблицу имен хостов для IP-адресов.
/etc/resolv.conf
    Файл, содержащий IP-адреса серверов имен, к которому система должна обращаться при любых попытках разрешить имена в IP-адреса. 
ifconfig
ip addr   - показывают инфу о сетевых интерфейсах
route - показывает маршруты
ip route - тоже
ping -c 5 ip_address - пинг 5шт
netstat -r - маршруты
netstat -i - инфа о сетевом трафике
netstat -tln - все открытые порты tcp
ss
ss -s - отобразить сокеты
dig google.com - запрос к гугл ком чтоб узнать работает ли днс
 host -a it-primyshev.site - узнать тнфу о хостеat
 



last и lastb - команды для просмотра логов в дыоичном виде
dpkg -L packagename - получить список расположения файлов
rpm -ql packagename - тоже для redhat




root@291417:~# - Если в начале строки символ #, это значит что мы работаем из под root
yura@291417:~$ - значок $ значит из под обычного пользователя
type команда - показывает что это: встроенная системная команда , алиас или бинарный файл
whereis команда - показывают абсолютный путь до команды исполнителя и до страницы Man
which НК - путь только до команды
file название_файла - показыает тип файла
stat название_файла - выводит инфу о файле в тч временные метки
locate нф - ищет все файлы которые содержат название указаного файла. Ищет в БД, предварительно созданной. Если файл создан недавно, то его не найдет. Надо обновить БД. 
updatedb - обновляет БЛ команды locate
find где_искать -iname НФ - ищет файл по точному имени без учета регистра
less - листать кнопками w, z
     - / что искать 
     - n, N - листать среди найденного
cat
cat файл1 файл2 - выводит обьединенные файлы
cat -n НФ - нумерует все строки файла

split
split НФ - делит файл на нескольео файлов по 1000 строк каждый. Названия дает с префиксом - x. 
split НФ префикс - любой префикс вместо x
split -d НФ - вместо aa, ab и тд называет файлы числами - 01, 02 и тд

nl
nl НФ - нумерует строки (не пустые)
nl -ba НФ - нумерует все строки

head
по умолчанию выводит ппрвые 10 строк
head -5 или head -n 5 или head -n5 - выводят 5 строк
head -n -5 выводит все строки кропе 5ти последних 

tail
показывает 10 строк в конце файла 
tail -n +20 - показывает все строки кроме первых 20тт
tail -f - для просмотра логов в режиме онлайн

paste
paste НФ1 НФ2 - обьединяет файлы построчно разделяя табом
paste -d , НФ1 НФ2 - разделяет запятой

join
обьединяет 2 файла но имеющих общие поля

cut
вырезает инфу из файла 
head -1 etc/passwd | cut -d: -f1,5,6,7 - сначала с помощью команды head отделчем только первую строку из файла, перенаправлчем ее на ввод клманды cut и опуией -d усианавливаем сепаратор для ориентира, а опуией -f кстанавлмваем какие столбики вырезать
если надо вырезать столбики(по кол-ву символов), то используем:
| cut -c 1-15

sort
сортирует по ASCII
sort -u убирает дубликаты
sort -t: -n -k3 mypasswd - разделитель :, сортировка по числовому значению, 3я колонка


uniq
uniq -u - отоьразить только уникальные строки

od - команда показывает данные файла в разных форматах

tr - меняет одни симврлы на другие (читает данные из STDIN)
cat file1 | tr '1-3' 'a-c' - изменит цифры 1,2,3 в файле1 на символы a,b,c
Так же может убирать повторы с помощью аргумента -s
sysadmin@localhost:~/Documents$ echo 'aaaaaappleeeeee' | tr -s 'ae'
apple
Может удалить символы:
sysadmin@localhost:~/Documents$ cat alpha-first.txt | tr -d 'AEIOUaeiou'
 s fr nml  

sed - stream editor
меняет данные на ленту по шаблону s/PATTERN/REPLACEMENT/
sysadmin@localhost:~/Documents$ sed 's/Animal/Apple/' alpha-first.txt
A is for Apple
B is for Bear
C is for Cat
/PATTERN/d - удалить паттерн

Редактор VI
Command mode
insert mode
Ex/last-line word

xargs
Команла принимает потом вывода другой команды на свой поток ввода и использкет его как аргумент другой команлы 
echo 'НФ1 НФ2' | xargs touch
Создаст НФ1 и НФ2







Как запускается команда. Сначала система ищет встроена ли она в оболочку (cd), если не находит, то ищет в алиасах (ls), если и там нет, то по порядку ищет в окружении (переменная $PATH, она хранится в памяти)
    yura@291417:~$ type cd
    cd is a shell builtin
    yura@291417:~$ type ls
    ls is aliased to `ls --color=auto'
    yura@291417:~$ type mkdir
    mkdir is /usr/bin/mkdir
    yura@291417:~$ echo $PATH
    /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    Порядок директорий в $PATH задан в файле home/пользователь/.profile

    alias ll="ls -lai --color=auto"
    alias grep="grep --color=always"


    Хэширование команд
    yura@291417:~$ hash
hits    command
   2    /usr/bin/whereis
   2    /usr/bin/nano
   1    /usr/bin/rm
   2    /usr/bin/ls
    Баш один раз смотрит где файл и потом им пользуется
    hash -r - для очистки хэша 



cd директория - переместиться в директорию
    cd .. - вернуться в предыдущую директорию 
    cd ~ - перейти в домашний каталог (можно просто cd без всего)
    cd - - перейти в директортю в которой были до этого и вышли
ls -la - отобразить содержимое директории с правами (-l) и скрытыми файлами (-a) 
    ls -li - отобразить номера inode (файловый дескриптор=inode)
    ls -l директория - укажет инфу содержимого директории
    ls -ld директория - укажет инфу именно о директории как файле 
    ls -lh Нф - укажет размер в human-read формате
    ls -R каталог - показыает все файлы в папках и вложеных папках
    ls -ls - по размеру
    ls -t - по времени 
    ls -t --full-time - по времени более точно
    ls -lrt - обратная сортировка по времени опцией -r, не путать с -R
    ls -- - говорит что команда используется без опций или опции закончены
    
В BSD опции прописываются без дефиса (осиалось пара команд которые поддерживают запись опций без дефиса - ps и tar)



alias ll="ls --color=auto -a -i -l" - алиас для ls -lai
cat файл - отобразить содержимое файла
touch файл - создать файл (по факту сменить время)
less файл - просмотреть файл с возможностью листать
mkdir директория - создать директорию
mkdir -p dir1/dir2/dir3 - создать одну в другой и в той еще одну
rmdir - удалить пустую директорию
rm -r директория - удалить даже не пустую директорию
УДАЛЕНИЕ определяется правом на каталог в котором находится файл, а не правами на файл. Если у вас есть права на запись на каталог, то вы можете удалить все файлы, которые в нем (удалить инфу об айнодах если точнее)
tput reset ^M - чтобы закрыть слsучайно открытый бинарник в терминале.
cp -r какую_директорию куда - скорировать диреторию со всем содержимым -(не важно какую)

yura@291417:~$ who - кто сейчас нп сераеое, с каеого ip
yura     pts/0        2023-05-01 01:50 (88.241.51.147)
cp -a если копирует рут, то влалельцем файла остается пользователь, создавший файл, а если не рут, то влалельцем становится скопировавший

uname -a - инфа о системе

apt dist-upgrade - обновляет системные файлы, докачивая или удаляя, если без dist, то обновятся      только установленные пакеты
apt remove название_программы - удаляет программу без конфигов
apt purge название_программы - удаляет и программу и конфиги
apt search ключевое_слово - ищет программу в репозиториях по слову
apt autoremove - удаляет зависимости уже удаленных программ
apt autoclean - удалить старые архиыные файлы
apt install -f - если сломались зависимости например при обновлении
apt edit-sources - редактировать файл sources.list
neofetch - утилита информации о системе красивая
curl -o /etc/yum.repos.d/konimex-neofetch-epel-7.repo https://copr.fedorainfracloud.org/coprs/konimex/neofetch/repo/epel-7/konimex-neofetch-epel-7.repo

systemctl status процесс - показать статус процесса
    systemctl stop/start процесс- запустить/остановить процесс
systemctl enable/disable программа - вкл или выкл из автозагрузки
systemctl reload программа - перезагрущить программу 
systemctl list-units --type=service - показать сервисы
systemctl list-timers --all - показать все таймеры
systemctl enable name.timer
systemctl disable name.timer


apropos слово - ищет описание по ключевому слову 
    apropos -s 1 passwd - найти утилиту смены пароля
    Обратите внимание на число в скобках после имени команды. Это глава или раздел справочного руководства man, в которых может встречаться описание утилиты. Разделов много, приведем самые полезные: 
●	1 — команды пользователя, 
●	2 — системные вызовы ядра (используется программистами), 
●	5 — форматы файлов, 
●	8 — команды администрирования.
whatis команда - выводит инфу о команде
man команда - справка о команде
    /слово - поиск конкретного слова в справке (следующее - n)
find ./ -name "название файла" - икать в корневой директоррии файл
grep -rin --include="*.py" "фраза" . - ищем фразу "фраза" рекурсивно (r) внутри всех файлов .py в текущей директории без учета регистра (i) и с указанием номера строки (n)
ripgrep (rg) -i "фраза" - по умолчанию раьотает в рекурсивном режиме



/etc/passwd - здесь хранится инфа о пользователях (тут можно сменить домашний каталог)
/etc/group - инфа о группах
/etc/shadow - инфа о паролях


    Пользователи


id имя_пользоватля - инфа о uid, gid
groups - в какие группы входишь
whoami - под каким пользоватеоем раблтаю
newgrp НГ- сменить группу под которой раьотаешь в данныц момент
chgrp НГ НФ - сменить группу у сцществ файла


аутентификация - проверка существования пользователя и пароля
авторизация - проверка ваших прав на какие-либо действия
adduser имя - добавть юзера
adduser существующий_юзер группа - добавить юзера в группу
sha256 - secure hash algoritm это хэш функция

             Права доступа (PERMISSIONS)

SUID setuid - u+s (вместо x), 4000 - позволчет запускать файл, как будто его запустил собственник (смена пароля через passwd)
SGID setgid - g+s , 2000 - позволяет запускать файл от имени группы владельца
SGID setgid для директории,g+s, 2000 - все файлы создаваемые в этой папке будут принадлежать владельцу директории. 
sticky bit o+t, 1000 - на папке, тогла файлы в этой папке может удалить только влпделец папки
umask - узнать маску разрешений (обратная маска, 777 для папок, 666 для файлов)


Читать:
    В file это позволяет процессам считывать содержимое файла, что означает, что содержимое может быть просмотрено и скопировано.

    В каталоге могут быть перечислены имена файлов в directory, но другие сведения недоступны.

    sysadmin@localhost:~$ ls -l test/                                               
    ls: cannot access 'test/file': Permission denied                                
    total 0                                                                         
    -????????? ? ? ? ?            ? file   

Писать:
    file может быть записан процессом, поэтому изменения в файле могут быть сохранены. Обратите внимание, что для корректной работы с большинством приложений разрешение на write обычно требует разрешения на read файла.

    В directory файлы могут быть добавлены в каталог или удалены из него. Обратите внимание, что для корректной работы разрешения на write требуется разрешение execute каталога.

Исполнять:
    file может быть выполнен или запущен как процесс.

    В каталоге пользователь может использовать команду cd, чтобы «войти» в каталог и использовать каталог в качестве пути для доступа к файлам и, возможно, подкаталогам в этом directory.

suid бит нужен чтоюы мы могли внести изменения в файл, к которому у нас нет доступа. Например изменить свой пароль (если вы не рут) в файле /etc/shadow
-rwsr-xr-x 1 root root 63736 Jul 27  2018 /usr/bin/passwd - этот бинарный файл является командой для смены пароля пользователя, который хранится в /etc/shadow
Если будет запущен этот файл /usr/bin/passwd, то владелец процесса будет равен владельцу этого файла. Те файл запускается от имени своего владельца, а не от имени того кто его запустил. Это благодаря suid биту.
Установить SUID можно с помощью команды:
chmod u+s myfile
chown - смена владельца файла 

chmod u/g/o-/+r/w/x файл - изменить права user group or other + or - read write executable, например 
    chmod o+x файл, если не указать никого то права изменятся у пользователя и у группы
    chmod -R 750 каталог - задать данные права на все все файлы в каталоге и каталог
    Надичие t-бита у каталога означает, что только владелец может удалять и переименовывать файлы (+t)
Права доступа для директорий
    Атрибут x даёт доступ к inode и на чтение, и на запись. Если атрибут x снят, файл невозможно ни изменить, ни прочитать из-за невозможности получить доступ к атрибутам.
Если у директории нет права на чтение, вы не сможете посмотреть ее оглавление. Но если знаете имя файла, сможете его посмотреть, явным образом указав его по имени.

newgrp group_name - сменить группу по умолчанию (чтобы при создании файла владельцем был указана другая группа)
Эта команда меняет оболочку и чтобы переключится на дефолтную группу надо нажать exit
usermod -g groupname username - постоянное изменении основной группы
chgrp group_name file - изменение группы сущ файла
chgrp -R development test_dir - изменить владельца группы всех вложенных файлов и папок

chown user /path/to/file - изменить владельца файла
может быть выполнена только рутом 

chown user:group /path/to/file - изменить и польз и группу
chown user.group /path/to/file

chown :group /path/to/file - изменить только группу
chown .group /path/to/file

разрешение -x для директории разрешает пользователю команду cd, если у каталога нет разрешения -x, 
то в папку не войти, нельзя посмотреть что внутри, и нельзя производить никакие действия с фыайлами внутри. Если попытаться открыть файл текстовым редвктором, то он откроется но ничего не покажет.




> файл- стандартный поток вывода в файл (работает справа налево)
2> файл - стандартный поток ошибок файл
>> файл - перезаписать файл
&> - записать в файл оба потока


ll asdf . 1> file 2>&1 - записать в file и STDOUT и STDERR (& - амперсанд это указатель) Сначала поток 1 будет перенаправлен в file, а затем поток 2 будет перенаправлен туда же куда и поток 1

ll asdf . 1> STDOUT 2> STDERR - записать в один файл поток ввода, а в другой поток ошибок

ll asdf . 2>&1 | grep слово_для_поиска - второй поток мы перенаправляем в первый, а первый в grep. Поэтому grep найдет и ошибки и норм информацию, смотря от запроса

ll asdf . 2>&1 1> /dev/null | grep слово_для_поиска - перенаправляем в grep только стандартный поток ошибок

echo $? - показывает код выполнения последней команды (0 или не 0)




Данные хранятся на диске. Информация о том где именно на диске хранятся эти данные + права + размер + время создания файла (записи информации на диск  и т.д. хранится в айноде. И эта айнода имеет назавание для нашего удобства - имя файла. Таким образом файл это просто именованная область данных на диске. Ядро обращается к информации по номеру айноды.
Вся информация о файлах в каталоге (директории) хранится в этом же каталоге. В каталоге как в библиотеке. Таким образом каталог это просто файл с информацией. С одной стороны написано имя, а с другой номер айноды. В линукс всё есть файл.


hard link - это просто имя файла в данном каталоге
ln test test_hl - создание хард линка для файла тест (ln что_линкую куда_линкую)
В каталоге в столбике отображается количество хард-линков на файл:
    root@291417:~# ls -li
    total 32
    12605 -rw-r--r-- 1 root root     1 Aug 19  2019 lsblk_raw
    3362 -rw-r--r-- 1 root root 18563 Apr 23 19:31 test-docker.sh
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test_hl  - вот хард линк, айнода 5258 и как у оригинала
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test.txt

stat имя_файла - отображает инфу из айноды

ln -s test.txt test_sl - создать софт линк
    root@291417:~# ls -li
    total 36
    5264 -rw-r--r-- 1 root root   523 Apr 24 23:50 copy_text.txt
    12605 -rw-r--r-- 1 root root     1 Aug 19  2019 lsblk_raw
    3362 -rw-r--r-- 1 root root 18563 Apr 23 19:31 test-docker.sh
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test_hl
    10556 lrwxrwxrwx 1 root root     8 Apr 24 23:57 test_sl -> test.txt - вот это софт линк
    5258 -rw-r--r-- 2 root root   523 Apr 24 23:16 test.txt

НАЙТИ ВСЕ INODE

sysadmin@localhost:~$ ls -i file.original 
278772 file.original
sysadmin@localhost:~$ find / -inum 278772 2> /dev/null - 
/home/sysadmin/file.hard.1
/home/sysadmin/file.original


ps aux - отображает процессы пользовательского пространства и потоки ядра (отображаются в квадратных скобках)
    ps -T -p 4242 - xтобы посмотреть потоки, используйте ключ -T, если хотите посмотреть потоки конкретного процесса, используйте ключ -p
top и htop - утилиты мониторинга процессов

kill -15 PID_процесса
kill -9 PID_процесса - завершить процесс. 
    ●	9 (SIGKILL) — безусловное завершение программы. Сигнал не может быть перехвачен программой, потому позволяет её остановить в любом случае (но не позволит снять процесс-зомби). 
    15 (SIGTERM) — вежливая просьба программе завершить работу. Программа может сохранить данные и т.д.
nice -n 10 название процусса - понизить приоритет процесса
ps aux - отобразить все процессы с колонкой юзеры
pstree - дерево процессов


               Ахивирование

gzip и gunzip
gzip НФ - создает архив с расш .gz и удаляет оригинал файла 
gunzip НА - распаковывает и удаляет архив
gzip -c НФ > НА(любое) - опция -с и такое перенаправление позволяет сохранить оригинальный файл
 
zcat НА - показать сожержимое архива безраспаклвки

gzip -r Название_директории_с_файлами - сжимает директорию с файлами внутри
gunzip -r НД - декомпресс директории с файлами

bzip2 и bunzip2 
сжимает лучше gzip, так как использует доугой алгоритм сжатия, но больше нагрушка на проц
Синтаксис так же как и gzip and gunzip

bzcat НА - выводит содержимое архива

bzip2 не поддерживает -r (компрессию вложенных папок)


xz и unxz
xz НФ - компрессит файл
unxz НА - декомпрессти файл

tar
Это Архиватор, не Компрессор
tar -cf НФ.tar ЦФ - архивирует Целевой файл в файл с названием НФ.tar, опция -c create , -f имя файла
tar -tf НА - опция -t показывает содержимое архива
tar -tvf НФ - опция -v verbose 
tar -xf НА - -x extract распаковать архив
tar -xvf НА.tar -C НП - извлечь в папку, а не в текущкю директорию

примеры:
tar --totals -cvf archive.tar file1 file2 file3 - создание архива
tar -tf archive.tar - вывести содержимое архива без распаковки
tar -xvf archive.tar - разархивировать архив
tar -xvf archive.tar -C /home/yura - разархтвировать архив в другой каталог
tar -cjvf archive.tar.bz2 file1 file2 file3 - сделать архив и сжать с помощью bzip2
tar -czvf archive.tar.gz file1 file2 file3 - сделать архив и сжать его с помощью gzip
tar -C "Test" -xjvf arhive.tar.bz2 - декомпресс bunzip2'ом и разврхивировать архив в папку Test
tar -xzvf archive.tar.gz - декомпресс gunzip'ом и разархивировать в текущую папку



xzcat НА - выводит содердимое архива

zip и unzip
Может и сжимать и архивировать
zip -r НФ НД - чтобы компресс и арх Директорию со всеми поддиректориями и файлами в Файл, используем опцию -r
unzip -l НА - показать файлы в архтве без распаковки
unzip HA - распаковать 

cpio
устаревшая
раьотает в 2х режимах in и out, через перенаправоение 

ls НД | cpio -ov > НФ.cpio - выводтт содердимое директории и перенаправояет в cpio в режиме out (-o) и записыает в архив 
cat НФ.cpio | cpio -iud - разархивирует

dd
if= входной фацл
of=выходной файл
bs=размер блока в байтах (можно в К, М, G)
count=сколько блоков копировать






 tar xvf архивный_файл куда_извлеч ь - разархивировать архив .tar 

Если вам попался пакет rpm (для систем типа Fedora, Mandriva, SUSE и т.д.), его можно сконвертировать в deb с помощью утилиты alien (устанавливается отдельно). Однако делать это рекомендуется лишь в исключительных случаях, когда пакетов deb в доступе нет (например драйверы принтеров Canon на официальном сайте выложены исключительно в rpm).

tar -xvzf архив.tar.gz -C папка_в_которую_надо_разархивировать
    x — дозволяет вам извлекать файлы из архива.
    v — делает вывод tar подробным. Это означает, что на экран будут выведены все выисканные в архиве файлы. Если эта опция опущена, информация, выводимая в процессе обработки, станет ограничена.
    f — является обязательной опцией. Без неё tar пытается использовать магнитную ленту вместо файла картотеки.
    z — позволяет вам обрабатывать архив, сжатый gzip’ом (с расширением .gz). Если вы забудете указать эту функцию, tar выдаст ошибку. И наоборот, эта опция не должна использоваться для несжатых архивов.
 
 unzip архив.zip - разархивировать архив .zip

 Установка программ с собственным инсталлятором
    INSTALL.sh. Если этот файл не захочет запускаться, вероятно, ему не даны права на запуск. Иногда дистрибутив программы распространяется в виде самораспаковывающегося архива. В таком случае это будет просто один-единственный файл .sh, который нужно запустить.
Установка программ из исходных текстов
    Основное, что понадобится — средства для компиляции, для этого сначала нужно установить пакет build­-essential. Дальше нужно распаковать архив с кодами программы во временную папку. Потом нужно найти файл README или INSTALL, прочитать его и выполнить то, что там написано. Чаще установка программ таким способом ограничивается последовательным выполнениям следующих команд:
    ./configure 
    make
    sudo make install
Файл .deb
    dpkg -i имя_пакета.deb
Snap
    snap install название_программы



 Системный список репозиториев содержится в файле /etc/apt/sources.list. Чтобы добавить репозиторий,­     отредактируйте файл так:
    sudo nano /etc/apt/sources.list

    Добавьте туда APT-строку. Чем «выше» (ближе к началу файла) стоит строка, тем больший приоритет получит добавленный репозиторий.
    Далее следует обновить список пакетов. Для этого выполните:
    sudo apt­-get update

    sudo apt­-key add ключ_репозитория.key - добавление ключа репозитория

Для хранения логов предусмотрена директория /var/log
Общесистемные логи, как правило, хранятся в файле /var/log/syslog (или в /var/log/messages, например в Centos)
Сообщения ядра хранятся в /var/log/dmesg

journalctl -e - смотреть логи (-e просит показать сразу поледнюю страницу пейджера)
journalctl -eu sshd - показать лог определенного юнита



tail -f /var/log/syslog - показывает последние строки по мере их появления
tail файл - выводит последние 10 строк
    - n кол-во_строк - показать количество строк
head файл - выводит первые 10 строк

Для запуска системных утилит и других программ служит командный интерпретатор или, как его еще называют, оболочка (shell), основной инструмент системного администратора Linux. Интерпретатор — своего рода язык программирования, позволяющий создавать сложные сценарии (скрипты), также он используется интерактивно для последовательного ввода команд.

cat файл1 файл2 - считывает данные из файлов и выводит их содержимое файлов в единый поток
wc - считает еоличество строк, символов и т.д.

cat -n файл - выводит содержимое файла и нумерует строки

SELinux — система с принудительным контролем доступа. Сложна в настройке, но позволяет с ювелирной точностью настроить те системы, которым критична безопасность

id имя_пользоватля - показывает инфу о пользователе
usermod -aG sudo имя_пользователя - добавить пользователя в группу судо, сли убрать ключ -а, то пользователь выйдет из всех остальных групп

oga@uho:~$ ls -lL /dev/cdrom 
    brw-rw----+ 1 root cdrom 11, 0 июня   1 13:33 /dev/cdrom                                
    Видно, что права на чтение и запись имеют пользователи, которые входят в группу cdrom.
    Обратите внимание на признак блочного устройства в первой позиции атрибутов. 
    Плюс в конце строчки прав означает, что используются ACL, можно их посмотреть командой getfacl. 

                              Создание пользователей и групп

groupadd НГ - создать группу
groupmod -n новая старая - смена названия группы (но не GUID)
groupmod -g - смена GUID группы
find / -nogroup - поис файлов, которые принадлежат только GUID и не имеют названия группы
groupdel - удаление группы

useradd -D - значения по умолчанию при создании пользователя, хранятся в файле   /etc/default/useradd
useradd -g - создать пользователя, но использовать де дефолтную группу а другую

/etc/login.defs - инфа о насройках при создании юзера

passwd - для смены пароля

getent passwd/shadow/group - можно смотреть файлы



Создадим группу developer:
# groupadd developer

Создадим двух пользователей — ivanov и petrov:
# useradd -m -G developer -s /bin/bash ivanov
# useradd -m -G developer -s /bin/bash petrov

Мы использовали опции: 
-m — также создать домашний каталог. По умолчанию каталог создаётся в /home с именем учётной записи, например, /home/ivanov. Если надо создать нестандартный каталог, можно указать его, используя параметр параметра -d. 
-G — список групп, к которым принадлежит создаваемый пользователь. По умолчанию также создается персональная группа пользователя с именем учётной записи. Она является первичной и по умолчанию все файлы пользователя создаются с этой группой в качестве группы-владельца. 
-s — задает оболочку пользователя. Для обычных пользователей обычно это /bin/bash. Для ftp/sftp-пользователей и системных псевдопользователей на этом месте указывается псевдооболочка, например, /usr/sbin/nologin или /bin/false. 
Иногда бывает полезным указать номер пользовательского ID явным образом с помощью параметра -u : например, -u 1001. Это бывает полезным, если у вас несколько систем с одинаковыми учетными записями и вы хотите, чтобы при переносе файлов на флешке между ними, у файлов был один владелец. Для этого надо следить, чтобы на системах одинаковые пользователи имели один UID. То же самое для групп: у groupadd есть параметр -g для указания GID. 
По умолчанию для новых учетных записей без пароля заблокирован вход в систему, поэтому установим пароль для пользователей с помощью passwd, например:
# passwd petrov

Есть альтернативный способ создания пользователя.
# adduser yura

Предложит несколько вопросов, ответив на которые, мы полностью сконфигурируем будущего пользователя, в том числе и его пароль.
Если нам понадобится изменить параметры для уже созданного пользователя, поможет утилита usermod. Параметры аналогичны утилите useradd. Также её можно использовать для блокировки/разблокировки пользователей. Опция -L позволит заблокировать учётную запись. Операция блокировки добавляет символ «!» в начало пароля в файле /etc/shadow. Параметр -U снимает блокировку. Для удаления учётной записи предназначена утилита userdel. Полезный ключ -r удаляет из системы домашний каталог пользователя. 

usermod -a -G sudo yura - добавить (-а) пользователя Юра в группу (-G) sudo
deluser yura sudo - удалить пользователя Юра из группы sudo

chfn - с помощью даной команды юзеры могут модифицтровать инфу о себе
finger имя_пользователя - аналогичная команда, но чтобы узнать инфу о других пользователях

gpasswd -A test_user1 test_user1 - сделать данного пользователя адмнистратором своей группы, что даст ему возможность добавлять в нее дркгих пользоватлей командой:
    gpasswd -a sysadmin test_user2

passwd -S sysadmin - посмотреть инфу по паролю                                        
sysadmin P 04/24/2019  0 99999 7 -1

passwd -e sysadmin  - при выполнении от рута, пароль юзера истекает и он вынужден его сменить при следующем логине

chage -l [USERNAME] - инфа о устаревании  пароля, а так же можно изменить нужные параметры

passwd -d sysadmin - удалить пароль (вход в систему возможен без пароля)
passwd -l/-u имя_пользователя - заблокировать/восстановить юзера (перед паролем появится/исчезнет знак - !)




newgrp Название_группы - позволяет пользователю запустить новую шелл сессию с другой primary group







                Регулярные выражения 
    ip a | grep -P '([0-9a-f]{2}:){5}[0-9a-f]{2}' - для поиска мак-адреса
    ip address | grep --colour=always -P "((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})" - для ip адреса
    ip address | grep -P "((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)" - или такое

    . - любой символ
    .* - любой символ сколько угодно раз
    ^ - начало строки
    & - конец строки
    ? - означает что предыдущий символ встречается 0 или 1 раз
    [^1-5] - символ ^ в начале диапазона, означает "все кроме"
    grep -i - игнорирование регистра 
    grep -r что где - иакать рекурсивно, те внутри папок 
    grep -c что где - сколько совпадений
    grep -n - отобразит номкра строк, где есть совпадение
    grep -v - инвертирует поиск, отображая вс строки где нет совпадений
    grep -w - ищет только цулые слова, а не совпадения
    Выражение "^$" соответствует пустой строке.


    BASH 
    echo $? - показывает код возврата последней команды (0 или не 0). Эта переменная хранит последний код возврата. Названия переменных начинаются со знака $.
    В BASH правда (true) это - 0
                    false - не 0
    команда1 && команда2 - если команда1 завершилась корректно (код возврата 0), то начать выпонять команду2. Это логическое И.
    команда1 || команда2 - логическое ИЛИ. Если команда1 отработает корректно, то 2 не будет стартовать, а если не отработает корректно, то будет.
    команда1 ; команда 2 - выполнять все команды вне зависимости от того как они выполнились. Это логическое НЕ ИМЕЕТ ЗНАЧЕНИЯ
    
    for year in {2015..2020}; do echo $year; for month in {01..12}; do echo $month; done; done

                                КРОН (CRON)
     /etc/crontab - общий КРОН

     # Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly
25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )

*/2 - каждые 2 минуты
* 2 * * * * - каждую минуту как стукнет 2 часа ночи (потому что крон запускается раз в минуту)
1 2 * * * * - вот правильный вариант
01 02 * * * - или так тоже правильно

crontab -e - редактировать свой локальный кронтаб_файл 
crontab -l - посмотреть расписание крона
crontab -r - удалить свой кронтаб_файл
crontab –u user_name - для редактирования файлов какого-либо юзера рутом
crontab –u user-name -r - для удаления кронтаба юзера админом 
ы

var/spool/cron/crontabs/имя_пользователя - тут хранится расписания для пользователя, которое он создал

/etc/crontab - здесь хранится расписание общее
/etc/cron.d/ФАЙЛ - тут можно создать файл с ссинтасисом как в crontab для выполнения. Тут обычно создаются такие файлы какими либо программами, которые вновь установлены.

/etc/cron.deny - указанные здесь пользователям запрещено пользоваться кроном
/etc/cron.allow - если данный файл существует, то только те кто указан тут могут пользоваться кроном

                            AT

Позволяет выполнять команды в определенное время один раз, но не по расписанию.

Keyword/Date Format 	        Significance
midnight 	                    12:00 a.m. 2nd Mar 2025
noon 	                        12:00 p.m .1st Mar 2025
tomorrow                       	8:00 a.m. 2nd Mar 2025
next week 	                    8:00 a.m. 8th Mar 2025
1630 	                        4:30 p.m. 1st Mar 2025
4:30 PM Mar 20                 	4:30 p.m. 20th Mar 2025
now + 2 hours 	                10:00 a.m .1st Mar 2025
now + 7 days 	                8:00 a.m .8th Mar 2025

sysadmin@localhost:~$ at now - вводишь когда
at>                          - вводишь команду
Далее появляется запрос еще одной команды, если надо выйти нажимаешь CTRL+d

sysadmin@localhost:~$ at 1000                                               
warning:  commands will be executed using /bin/sh
at> echo “Planning meeting in 30-minutes” > /dev/pts/0
at>  <EOT>
job 2 at Mon Feb  10  09:26:00  2025

Выполняет скрипт из файла и отсылает результат на почту юзера
sysadmin@localhost:~$ at -m -f backup_script.txt  10 pm  Mar 22                                               
warning:  commands will be executed using /bin/sh
job 5 at Mon Feb  10  09:33:00  2025

atq - помотреть список jobs (очередь)
atrm 2 - удалить job под номером 2
                                BATCH

Команда будет выполнена сразу как нагрузка на проц (load average) упадет до 80% (0.8)

sysadmin@localhost:~$ batch
at> sort  ~/marketing_data
at> <EOT>
job 5 at Mon Feb  3  09:26:00  2025

                        SYSTEMD timers

sudo systemd-run --on-active="1m" /bin/touch /home/sysadmin/newfile - создать таймер создающий файл через минуту
systemctl list-timers - посмотреть список активных таймеров

Systemd использует два разных типа таймеров; monotonic и realtime. При использовании монотонных таймеров таймер systemd позволяет выполнить задание после того, как произошло событие. Этот тип можно использовать для запуска задания, когда система загружается (опция OnBootSec) или активен модуль systemd (опция OnActiveSec). Приведенный ниже пример файла greeting.timer представляет собой монотонный таймер, который использует опцию OnBootSec для запуска таймера через десять секунд после загрузки системы:                        

    [Unit]
    Description=Displays greeting after boot
    
    [Timer]
    OnBootSec=10sec
    Unit=greeting.service
    
    [Install]
    WantedBy=multi-user.target

    Секция 	Описание

[Unit]	
Общая информация о файле systemd. Description создает удобочитаемое имя для модуля systemd.

[Timer]
Содержит параметры, определяющие, когда будет запускаться таймер и какую службу выполнять.

[Install]	
Содержит информацию о том, как будет установлено устройство. Параметр WantedBy= создает символьную ссылку на целевом уровне, которая «хочет», чтобы эта служба работала.

Таймеры реального времени работают как cron и выполняют задание, когда наступило указанное время. Чтобы создать таймер реального времени, следует использовать опцию OnCalendar в разделе [Timer] файла ..timer Формат записи времени OnCalendar:

    DayofWeek Year-Month-Day Hour:Minute:Second

Ниже приведен пример блока таймера, который выполняется каждый день в 9:00 утра:

    OnCalendar=*-*-* 9:00:00


                        LOCALE

language[_territory][.codeset][@modifiers] - соглашение об именовании
Например:  en_US.utf8 или ru_RU.utf8

locale -a - вывести список всех доступных локалей в системе
locale - посмотреть какая локаль применена (текущий языковой стандарт)
   Показанные переменные, значения которых заключены в кавычки, не задаются явно; они наследуют свои значения от LANG или LC_ALL. Значения без кавычек заданы явно.
   Можно поменять те которые с кавыками, напрмер:
    LC_TIME="en_US.UTF-8"
    export LC_TIME
   Или сменить все
    LC_ALL="ru_RU.UTF-8"
    export LC_ALL
    unset LC_ALL - вернуть как было 

Изменение настроек языкового стандарта системы по умолчанию для всех пользователей
1. Отредактируйте файл глобальных настроек локали:

    /etc/default/locale (системы, основанные на Debian)
    /etc/sysconfig/i18n (системы на базе Red Hat)

2. Измените переменную LANG (language) внутри файла на нужное значение (из списка доступных локалей):

    LANG="en_AU.UTF-8"

Если нужная локаль не доступна, то ее можно установить и даже сразу применить командой:
sudo dpkg-reconfigure locales

3. Перезагрузиться, или перезайти в систему или выполнить:
    source /etc/default/locale

Можно просто выполнить команду:
    sudo update-locale LANG=ru_RU.UTF-8

Чтобы прописать язык для каждого пользователя, то надо прописать строку в .bashrc:
    export LANG=en_US.UTF-8

Чтобы запутить команду используя определенную локаль, пример:
LANG=C apt update - запустит команду apt update с выводом на английском

iconv -l выдает список поддерживаемых кодировок
iconv –f old-encoding [-t new-encoding] file.txt > newfile.txt - синтаксис команды


                    TIME (ВРЕМЯ)

/etc/localtime - это конфигурационный файл локального часового пояса, в котором хранится общесистемный часовой пояс локальной системы, используемый приложениями для представления пользователю. Этот файл содержит двоичные данные и не редактируется напрямую.

cat /etc/timezone - показывает текущий часовой пояс
/usr/share/zoneinfo - содержит все поддерживаемые часовые пояса

tzselect - утилита для установки часового пояса
Чтобы сделать смену часового пояса постоянной для пользователя, добавьте следующую строку в ~/.profile или ~/.bash_profile в домашнем каталоге пользователя~/.profile

    TZ=’America/Los_Angeles’; export TZ

date MMDDhhmmYYYY.ss - установить дату и время
date -s “Mon Mar 23 17:00:00 UTC 2020” - или так

Изменение системного часового пояса с помощью метода командной строки
1. Сохраняем резерывную копию /etc/localtime
2. Найдите нужный город в каталоге usr/share/zoneinfo
3. ln -sf /usr/share/zoneinfo/Australia/Sydney /etc/localtime - создать символьную ссылку

Но проще через команду tzselect
sudo dpkg-reconfigure tzdate - или так 





МОНТИРОВАНИЕ

mount /dev/sda /mnt - примонтировать что и куда
df -h - выводит информацию о примонтированных устройствах
umount /mnt - откуда отмонтировать
umount /dev/sda - что отмонтировать
lsblk - вывести инфу о блочных устройствах (что куда примонтировано)
/proc/self/mounts - файл содержащий информацию о точках монтироваия
/etc/fstab - файл описывающий точки монтирования при старте Основное

            CENT OS


rpm -qi - инфа об установленном пакете
rpm -qp - инфа о неустановленном файле
rpm -qa - инфа о всех установленныых пакетах 
rpm -q название_пакета - установлен пакет или нет

        Восстановление удаленного файла
rpm -qas | grep whoami - показывает путь до файла, даже если он был удален
rpm -qf /usr/bin/whoami - узнать к какому пакету принадлежит файл, если известен полный путь до файла
или
yum provides путь_до_файла
скачать yum-utils
yumdownloader название_пакета - скачает пакет
Перейти в директорию с пакетом и выполнить команду:
rpm2cpio openssh-7.4p1-23.el7_9.x86_64.rpm > openssh.cpio - сменить формат rpm на cpio
less openssh.cpio - посмотреть что внутри rpm
или сразу скачать
rpm2cpio путь_до_скачанного_пакета | cpio -imud - скачаются все файлы пакета
Из них скопировать недостающий куда надо



rpm -qa *python* - установален пакет в системе или нет, если не помнишь точного назавания

rpm -qa - отобразить все установленные пакеты
rpm -qa название_файла - найти пакет по имени файла
yum remove пакет - удаление (без зависимостей)
rpm -e пакет - то же
yum provides название_файла - искать файл внутри пакета в репозитории 
rpm -ql название_пакета - смотреть файлы содеожащиеся в пакете 
rpm -qs  название_пакета - смотреть список файлов в установленном пакете
rpm -qi название_пакета - отобразить инфу о пакете
rpm -U - обновить
rpm -q --scripts - что выполняется во время установки
rpm -qp --requires путь до файла .rpm (имя можно указать частично, например apach*) - что надо пакету чтобы работать корректно (библиотеки, программы)
rpm -i /mnt/local_repo/quota* - установка пакета из локального репозитория

rpm2cpio - извлечт файлы с пакета

- qR - отобразить зависимости
- rpm -i название_пакета - установить пакет (если нет зависимостей, то будет неудача)

/etc/yum.conf - тут хранится конфиг
/etc/yum.repos.d - репы
yum provides название_файла - какому пакету принадлежит данный файл
yum search название - искать в репе
yum grouplist - отобразить все существующие группы пакетов
yum groupinfo имя_группы
yum groupinstall "Office Suite and Productivity" - установить даннаую группу пакетов
yum remove/erase название_пакета - удаление (с зависимостями)
yum list updates - посмотреть какие пакеты в системе требуют обновления
yum update - обновить пакеты

Чтобы сделать собственный репозиторий надо создать файл например local.repo в папке /etc/yum.repos.D
Содержимое:

[Local]
name=Local
baseurl=file:///mnt/local_repo
gpgcheck=0
enabled=1

Параметр baseurl определяет, где хранятся RPM-файлы. Обычно это сетевой адрес, основанный на http или ftp. Параметр gpgcheck установлен в 0, чтобы команда yum не проверяла цифровую подпись пакетов. Для разрешения использовать этот репозиторий enabled=1.

yum list available - отобразить пакеты доступные для установки (ищет по репам)


            DPKG

Если файл был удален, то:

 dpkg -S /usr/bin/whoami - показать какому пакету принадлежит файл
 dpkg -L coreutils | grep whoami - показать какие файлы находятся внутри УСТАНОВЛЕННОГО пакета
 apt-file list apache2 - какие файлы в пакете без его скачивания
 Предварительно надо установить и обновить apt-file
apt install apt-file
apt-file update

apt download apache2 - просто скачать пакет
или
apt-get install --download-only apache2 - только скачать пакет, без установки в папку /var/cache/apt/archives/
dpkg -c название_пакета - посмотреть содержимое .deb пакета
dpkg-deb -xv файл.deb куда - извлечь файлы из скачанного deb-пакета
или
dpkg --extract <file.deb> </path/to/extract>


dpkg -l - инфа о усиановленных пакеиах (ii) и удаленных, но после которвх что то осталось (rc)
УТИЛИТА top
apt-get update - обновляет список пакетов, о которых занет репозиторий на вашем компе
apt-cache depends - показать все зависимости

dpkg -i название_пакета - установить пакет (без зависимостей)
dpkg -r - remove, но оставить конфиги
dpkg -P (purge) - удалить всё
dpkg -l - отобразить все установленые пакеты
dpkg-reconfigure название_пакета - изменить параметры пакетва при установке или после


Как apt, так и apt-get являются инструментами для управления пакетами в дистрибутивах Linux на основе Debian. Есть и другие инструменты для этой задачи, например aptitude и synaptic.

apt-cache search KEYWORD - искать пакет в репах
apt-cache depends PACKAGE - посмотреть зависимости
apr-cache show PACKAGE - статус пакета
apt-get install PACKAGE - установка пакета с зависимостями
apt-get --only-upgrade install - только обновить один пакет

apt-get update - обновляет информацию об актуальных версиях доступных пакетов, а не сами пакеты
apt-get upgrade - обновить уже именно установленные пакеты (не удаляет сатрые версии в отличие от apt upgrade)

apt-get remove PACKAGE - удаляет без конфигов
apt-get purge PACKAGE - удаляет с конфигами

/etc/apt/sources.list - файл хранения репозиториев
/etc/apt/sources.list.d/ - для сторонних репозиториев
Тут надо создать файл с именем репы.list

sudo apt-add-repository 
sudo apt-add-repository'deb http://ftp.ru.debian.org/debian/ testing main non-free contrib' - для добавления офиц репозиториев

Касательно сторонних репозиториев, есть ещё один момент. По умолчанию система не может им доверять, и для того чтобы это исправить нужно импортировать ключ репозитория. Обычно ключи можно найти на сайте, где вы нашли сам репозиторий, для того же Google Chrome ключ можно импортировать командой:

wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -

или так

curl -LsSO https://mariadb.org/mariadb_release_signing_key.asc
    chmod -c 644 mariadb_release_signing_key.asc
mv -vi mariadb_release_signing_key.asc /etc/apt/trusted.gpg.d/

После apt update

md5sum название_файла > название_файла.md5 - вычислить md5 hash сумму и поместить ее в файл

md5sum -с название_файла.md5 - проверить 

            SUSE

Zypp/libzypp - пакетный менеджер SUSE
zypper - программа типа apt и yam



s - выставляем интервал обновления (по дефолту 3с)
load average - кол-во процессов в очереди на ожидание ресурсов (за 1мин, 5мин, 15мин)
    нормальное значение должно быть меньше или равно кол-ву ядер процуссора, однако бывают и странности когда оно равно 600, так как в мире LINUX в очередь попадают программы которые например ждут данные с устройств ввода-вывода.
1 - для отображения всех ядер

PR стобик - приоритет, по дефолту 20, чем ниже тем больше приоритет

Строчка 3.
us - информация о том, сколько процессорных ресурсов было израсходовано в пространстве пользователя
sy - на работу ядра (в пространстве ядра), например сеть или драйвера
ni - атавизм, сколько проц ресурсов было потрачено на процессы с поиженным приоритетом. Админ может понять есть ли у него резервные ресурсы, которые он может забрать у пользователей с низким приоритетом.
id - процесс простоя
wa - сколько пр времени было потрачено на общение с устройствами ввода-вывода, если будет 5-10% это уже будет ощущаться. Узкое место обысно сеть или диск
hi - сколько пр ресурсов было потрачено на обработку аппаратных прерываний
si - программные прерывания или системные вызовы, например торрент клиент при раздаче увеличивает этот параметр
st - как занята хостовая машина (реальная железка). Так как мы виртуальная машина. Не на всех гипервизорах это работает

ps -efl - показать все процессы, every, full, long, фул и лонг
Владелец процесса - это владелец каталога в папке /proc имя которого (имя каталога)  равно PIDу процесса
ps aux - процессы всех пользователей


watch
Позволяет онлайе наблюдать за процессом. Она как бы перезапускает уоманду ps каждые 2 секунлы
watch ps aux
watch -d НК - подсвечивает измененные места
watch -n 5 - каждые 5 сек
& - знак амперсанд после команды позволяет запустить ее фоном
sleep 3 & - запустит команлу слип на 3 сек фоном
jobs - показывает процессы запушенные фоном
jobs -l - больше инфы
fg номер процесса 
bg номер процесса
Ими можно доставать процесс из background в foreground и наоборот
CTRL+z - ставит процесс fg на паузу
kill -SIGSTOP $PID - пауза
kill -SIGCONT $PID - продолжить процесс
CTRL+c - осианавливает процесс 
nohup команда & - позволяет послать сигнал SIGHUP , разлогиниться, а процесс будет продолжать работать фоном

 Priority 
-20 наибольший
0 по умолчанию
19 наименьший 
nice -9 ls - поменять приоритет
renice - меняет приоритет уже запущенной команды 
Высокий приоритет может делать только Рут. 

top
Смотреть процессы в real-time
h help
r renice
q выход

uptime 
показывает время, скока раьотает система , колво пользоватеоей и загрузку процесмора (последнюю минуту,5 мин, 15 мин)

tmux
tmux ls - показать список сессий
tmux attach -t номер_сессии - запустить сессию
CTRL-B - режим ввода команд
CTRL-B+d - detach сессию
CTRL-B+% - новая сессия по горизонтали
CTRL-B+" - новая сессия по вертикали


            СЕТЬ
ip a - вывести ip адрес интерфейсов
ip r - показать шлюз
/etc/resolv.conf - адреса DNS серверов
    # Generated by NetworkManager
    search vds.as210546.net
    nameserver 8.8.8.8
    nameserver 1.1.1.1
ss -tnlp - какие порты доступны на нашем сервере (-t) TCP (-n) видеть все по номерам а не по днс (-l) listen (-p) какая служба

CENTOS
/etc/sysconfig/network-scripts/ifcfg-eth0 - конфиг сетевого интерфейсах
или
/etc/network/interfaces

ip link set ens33 down/up - выкл или вкл интерфейс

ip route show
или
ip ro sh
    default via 192.168.0.1 dev ens33 proto static metric 100
    192.168.0.0/24 dev ens33 proto kernel scope link src 192.168.0.163 metric 100

traceroute 1.1.1.1

nslookup ya.ru
    Server:         192.168.0.1  - адрес днс сервера
    Address:        192.168.0.1#53

    Non-authoritative answer:
    Name:   ya.ru
    Address: 77.88.55.242
    Name:   ya.ru
    Address: 5.255.255.242
    Name:   ya.ru
    Address: 2a02:6b8::2:242

nmtui - команда чтоб запустить псевдографический интерфейс для настройки СЕТИ


service network restart / service networking restart - перезапустить всю службу
или
ifdown eth0
ifup eth0

/etc/resolv.conf - содержит записи кто является dns сервером
/etc/hosts - содеожит прямое сопоставление ip - имя_сайта

/etc/nsswitch.conf - тут прописон порядок поиска имени хоста

ubuntu
cd /etc/netplan/ - в этой папке yaml файл со всей инфой
systemctl restart systemd-networkd.service


/etc/init.d/ - скрипты sysV системы инициализации.
    [root@291417 ~]# ls -l /etc/init.d/
    total 40
    -rw-r--r--. 1 root root 18281 May 22  2020 functions
    -rwxr-xr-x. 1 root root  4569 May 22  2020 netconsole
    -rwxr-xr-x. 1 root root  7928 May 22  2020 network
    -rw-r--r--. 1 root root  1160 Sep  1  2022 README

для upstart нет скрипта системы инициализации, так как Upstart обратно совмещен с sysV
    [root@291417 ~]# ls -l /etc/rc
rc0.d/    rc1.d/    rc2.d/    rc3.d/    rc4.d/    rc5.d/    rc6.d/    rc.d/     rc.local
    тут лежат скрипты для Upstart, но они сылаются на 2 скпипта sysV - netconsole и network

 /lib/systemd/system - каталог служб systemd

chkconfig --list - показать список сервисов в автозагрузке в Centos
chkconfig --level 345 httpd on - Добавить в автозагрузку


    Команда 	                            Описание
systemctl start name.service 	запуск сервиса
systemctl stop name.service 	остановка сервиса
systemctl restart name.service 	перезапуск сервиса
systemctl try-restart name.service 	перезапуск сервиса только, если он запущен
systemctl reload name.service 	перезагрузка конфигурации сервиса
systemctl status name.service 	проверка, запущен ли сервис с детальным выводом состояния сервиса
systemctl is-active name.service 	проверка, запущен ли сервис с простым ответом: active или inactive
systemctl list-units –type service –all 	отображение статуса всех сервисов
systemctl enable name.service 	активирует сервис (позволяет стартовать во время запуска системы)
systemctl disable name.service 	деактивирует сервис
systemctl reenable name.service 	деактивирует сервис и сразу активирует его
systemctl is–enabled name.service 	проверяет, активирован ли сервис
systemctl list-unit-files –type service 	отображает все сервисы и проверяет, какие из них активированы
systemctl mask name.service 	заменяет файл сервиса симлинком на /dev/null, делая юнит недоступным для systemd
systemctl unmask name.service 	возвращает файл сервиса, делая юнит доступным для systemd 


                    ВХОД ПО КЛЮЧАМ SSH
    Папка в дом директории .ssh, а в ней файл authorized_keys
    В нем прописано ssh-rsa ключ_в_одну_строку
    Если без ssh-rsa или ключ не в одну строку, то работать не будет

    ssh-copy-id id_rsa.pub yura@hostname - безопасно скопировать свой сгенерированный публичный ключ на сервер, на который будешь подключаться по ключам. Автоматически на нем создасться папка authorized_keys и пропишутся все права на нее.

    ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub  - сгенерить публичгый имея готовый приватный

    ssh root@192.168.1.1 команда - подключиться к серверу, выполнить команду и отключиться, вывод которой отобразиться у тебя на экране

    Есл серверов для подключения много и имена сложные, то можно сделать Алиасы для них сразу со всеми опциями подключения. Это делается в файле /etc/ssh/ssh_config или пользовательском файле (надп создать самостоятельно) ~/.ssh/config 
        Host Debian
        Hostname 212.192.31.43
        User root
        IdentityFile        можно указать путь до приватного ключа
        VisualHostKey yes        чтобы показывался фингерпринт хоста

        После этого можно подключаться просто вводя ssh Debian
    
    Опции файла /etc/ssh/sshd_config сервера к которому подключаешься - 
        PermitRootLogin yes/no/(prohibit)without-password - можно ли входить рутом по ssh. да/нет/только без пароля (те по ключу)
        PasswordAuthentication yes/no - можно ли подключаться к ssh используя пароль

scp authorized_keys root@194.87.199.75:/root/.ssh - скопировать файл например authorized_keys из текущей папки, директорию указывать через :

root@Debian:/etc/ssh# ssh-keygen -l -E md5 -f ssh_host_rsa_key.pub 
3072 MD5:f7:55:20:fe:8f:ed:2f:af:2f:6a:5a:33:7b:51:1f:05 - посмотреть фингерпринт ключа на сервере, который должен высвечиваться намклиенте при первом подключении к серверу 

ssh-keygen -lf ~/.ssh/id_rsa.pub - или так

getend passwd - отобразить файл passwd без входа в рут
getent group - посмотреть группы

Чтобы добавить пользователя в группу надо в файле /etc/group  в нужной группе после : написать имя пользователя

last - история входов в систему
Команда who считывает данные из файла /var/log/utmp, который регистрирует текущих пользователей, а last команда считывает данные из файла //var/log/wtmp, в котором хранится история всех входов пользователей./var/log/utmp


                    PARTITIONING

fdisk
Два режима работы:
- interactive (для изменения секций) and non-interactive (для перечисления секций)
По умолчанию вывод fdisk отображается в цилиндрах, а в ubuntu - в секторах. Чтобы отобразить вывод в цилиндрах есть опция -u=cylinders
fdisk -l - отобразить все разделы

Заметка
Таблица разделов, описанная выше, постоянно хранится в MBR. При загрузке системы в памяти создается копия. Эта копия используется ядром для различных системных задач. Ядро не может напрямую взглянуть на файловую систему, чтобы определить, к какому типу она относится. Таким образом, таблица разделов хранит эту информацию на благо ядра.
fdisk -l /dev/sda > mydisklayout.txt - перед разбиением на разделы лучше сохранить вывод команды в файл, чтобы потом откатить при необходимости

fdisk /dev/sda - интерактивное моде
n - создать новую партицию
d - удалить партицию
t - изменить файловую систему
w- записать изменения
q - выйти без изменений

sfdisk
Для автоматизации секционирования и сохранения резервной копии и восстановления таблица разделов
sfdisk -s - отобразить информацию о дисках в системе
sfdisk -d /dev/sda > sda.disk - сохранить резервную копию таблицы разделов  в файл
sfdisk -f /dev/sda < sda.disk - восстановить из файла

gdisk
Для работы с GPT разделами
gdisk /dev/sdb1 - надо указывать диск

parted
parted DEVICE - синтаксис команды

mkfs
Для создания файловой системы
mkfs -t ext4 /dev/sdb1
или
mkfs.ext4 /dev/sda1
Вся инфа будет стерта. НО команда не работает если раздел используется (смонтирован)

Раздел подкачки
fdisk с идентификатором 82
mkswap ИМЯ_РАЗДЕЛА - преобразовать раздел а раздел подкачки
или
mkswap -L myswap /dev/sdb6

swapon -a ИМЯ_РАЗДЕЛА - включить 
Работает до перезагрузки, иначе можно лучше примонтировать. -a означает добавить. 

swapon -a - эта команда перечитывает файл fstab

swapon -s - отобразить все разделы подкачки

Можно создать файл подкачки
dd if=/dev/zero of=/var/swapfile bs=1M count=100
Затем mkswap /var/swapfile
swapon /var/swapfile




далее отредактировать файл fstab
LABEL=myswap    nono    swap    sw  0   0



        Установка ОС с нуля

Сначала монтируем /boot на 512 MB или до 1GB и ставим пометку Загрузочный
Затем /
Затем swap раздел (он должен быть ближе к началу диска, где наиболее быстрые сектора)
Затем остальное

LVM
Можно увелчивать размер разделов на лету, без выключения компа. Если уменьшать раздел, то надо выключать машину, загружаться с загрузочной флешки и уменьшать.
- Выбираем все место на диске и создаем там один загрузочный раздел
Надо выбрать Использовать как: физический том для LVM 
Далее выбираем LVM
Создаем группу томов
Выбираем диски (или 1 диск) для этой группы
Далее создаем логические тома
Сохраняем, выходим в обычное меню и устанавливаем файловую систему и монтируем.

pvs - посмотреть есть ли на компе физичекие тома (phisical volume)
vgs - посмотреть Volume group
lvs - logical volume

df -h - посмотреть какие диски примонтированы (disk free )

pvcreate /dev/sda1 - создать физичекий том размером с партцию sda1 (можно создать и без партиции, просто подставив /dev/sda)

vgcreate vg_00 /dev/sda1 - создать volum groupe и добавить в нее наш физичекий том

lvcreate vg_00 -n lv_01 -L 100M - создать логический том в данной группе размером 100MB

mkfs.ext4 /dev/mapper/vg_00-lv_00 - создать файловую систему на этом логическом томе

mount /dev/mapper/vg_00-lv_00 /mnt/01 - примонтировать этот логический том  

после монтирования в точке монтирования появляется каталог lost+found - спутник файловой системы ext4

vgextend vg_00 /dev/sda2 - добавить к логической группе еще 1 диск

lvextend /dev/mapper/vg_00-lv_00 -L +200M - добавить к логическому тому еще 200MB
НО! Посл этого файдовая система еще не будет знать что появилтсь дополнительные мегабайты, поэтому надо сообщить ей об этом командой для файловой системы ext4
resize2fs /dev/mapper/vg_00-lv_00

lvextend /dev/mapper/vg_00-lv_00 -L +200M -r - уже с ключом resize!

pvmove /dev/sda1 /dev/sda3 - если надо вынуть диск один, то сначала нужно вставить диск 3, жобавить его в vg_00 и затем данной командой перенести данные с диска1 на диск3
Можно без указания куда, если это не важно

А теперь можно вывести том из группы
vgreduce vg_00 /dev/sda1 - какую группу на какой том уменьшаем

pvremove /dev/sda1 - вообще удалить логический том




RAID 
Надо делвть RAID1 (зеркалирование)
Выбираем диски и ставим в графе использовать как: физический том для RAID
Далее - настройки программного рейд массива
Создать MD устройство
Далее, далее, и потом уже создаем LVM (создаем группу и туда добавляем dev/md0)
Если надо зашифровать, то перед созданием LVM надо выбрать устройство RAID и его уже использовать как: физический том для шифрования

                    MOUNTING

mount  - посмотреть что подключено
lsblk -a - показывает блочные устройства
lsblk -f - показывает инфу о доступных файловых системах

/mnt и /media - для временного подключения
mount -t iso9660 /dev/scd0 /mnt - опция -t служит для указания какой либо особой файловой системы
mount /dev/sdb2 /opt -o ro - опция -o ro показывает что можно будет только читать 

umount ИЛИ /mnt ИЛИ /dev/sdb1 - отмонтировать (указать можно или точку монтирования или само устройство)

ЕСли не получается омонтировать:
lsof | grep /mnt - посмотреть все открытые файлы в данной файловой системе
fuser -v /mnt - посмотреть какой юзер использует файловую систему сейчас

fuser -k /mnt - завершить все процессы в точке монтирования 
fuser -k -KILL /mnt - убить все процессы 
umount -f /path/to/device - принудительное размонтирование. Может привести к потере данных
umount -l /path/to/dev - ленивое размонтирование


/etc/fstab - в файле солержится инфа о том что монтируется автоматически при загрузке
(сделать бэкап перед этим)
mount -a - перечитать файл fstab и при выполнение команды df-h должен появится ваш примонтированный диск(партиция). Если не появился, то надо исправлять файл fstab, иначе система не загрузится

 
 Лучше монтировать по UUID, так как он уникальный
 blkid - посмотреть UUID
 e2label ИМЯ_ДИСКА - посмотреть или изменить лэйбл
 e2label /dev/sda2 mydisk - поставить метку


 mount /home -o remount, noatime - переподключить с новой опцией

fsck - проверить файловую систему после сбоя 

mount -o loop cdrom.iso /mnt - позволяет монтировать файлы, снутри которых есть какая то файловая система (img, raw, iso)

df -h - посмотреть что примотинтировано с инфой в human format
df -T - показать файловую систему
df -i - показать кол-во inode
по дефолту показывает размер в блоках по 1 кбайту


du -h /ПАПКА - показать размер этой папки и всех подпапок
du -s /ПАПКА - только этой папки

du /etc |sort -nr | head - показать 10 самых больших папок в данной директории

du -h --max-depth=1 --exclude=/usr/lib/audit
- ограничивает глубину рекурсии в 1 и исключает из вывода папку

tune2fs -c0 -i0 /dev/sdb1 - По умолчанию, каждая файловая система будет проходить полную проверку системы в процессе загрузки либо каждые 180 дней, либо после 30 монтирований, в зависимости от того, что наступит раньше. Эта команда отключает это. 
-m	Укажите процент пространства, который должен быть зарезервирован для пользователя root или привилегированных процессов. Значение по умолчанию, равное 5%, часто является неоправданно большим для больших файловых систем.
-o	Укажите параметры монтирования по умолчанию. По умолчанию производные дистрибутивы RedHat указывают, что acl и user_xattrдобавляются к файловым системам, созданным во время установки. При применении нескольких вариантов их нужно разделять запятыми.
dumpe2fs /dev/sda1 | head - инфаа о файловой системе

dumpe2fs /dev/sda1 | grep "Free inodes" - инфа о свободных айнодах в файловой системе

После создания партиции на диске ядро не всегда сразу может ее видеть. Надо или перезагрузить или выполнить команду
partprobe
или
kpartx 


        ПРОВЕРКА ФАЙЛОВОЙ СИСТЕМЫ

Когда дело доходит до резервного копирования, опоздание может быть лучше, чем никогда. Если файловая система повреждена и не может быть смонтирована, подумайте о том, чтобы сделать ее резервную копию с помощью команды dd прежде чем пытаться исправить ее с помощью команды fsck. Таким образом, если исправление, выполняемое командой fsck, действительно ухудшает ситуацию, чем она была изначально, все равно можно вернуться к состоянию, сохраненному в резервной копии.

Поскольку корневая файловая система не может быть размонтирована во время работы системы, проверить ее может быть сложно. Одним из подходов к проверке корневой файловой системы является загрузка другой операционной системы Linux с другой корневой файловой системой. Распространенный подход заключается в загрузке и использовании Live CD-ROM, DVD или USB, которые являются загрузочными операционными системами Linux, которые помещаются на этих носителях.

Суперблок

Суперблок хранится в первом блоке каждой группы блоков (за исключением группы 1, в которой в первом блоке расположена загрузочная запись). Суперблок является начальной точкой файловой системы. Он имеет размер 1024 байта и всегда располагается по смещению 1024 байта от начала файловой системы. Наличие нескольких копий суперблока объясняется чрезвычайной важностью этого элемента файловой системы. Дубликаты суперблока используются при восстановлении файловой системы после сбоев.

Информация, хранимая в суперблоке, используется для организации доступа к остальным данным на диске. В суперблоке определяется размер файловой системы, максимальное число файлов в разделе, объем свободного пространства и содержится информация о том, где искать незанятые участки. При запуске ОС суперблок считывается в память и все изменения файловой системы вначале находят отображение в копии суперблока, находящейся в ОП, и записываются на диск только периодически. Это позволяет повысить производительность системы, так как многие пользователи и процессы постоянно обновляют файлы. С другой стороны, при выключении системы суперблок обязательно должен быть записан на диск, что не позволяет выключать компьютер простым выключением питания. В противном случае, при следующей загрузке информация, записанная в суперблоке, окажется не соответствующей реальному состоянию файловой системы.

fsck - проверить ФС (размонтированную!)
dumpe2fs - для поиска суперблоков

 dumpe2fs /dev/sdb1 | grep superblock 
 
 root@localhost:~# dumpe2fs /dev/sdb1 | grep superblock
dumpe2fs 1.41.12 (17-May-2010)
  Primary superblock at 1, Group descriptors at 2-2
  Backup superblock at 8193, Group descriptors at 8194-8194
  Backup superblock at 24577, Group descriptors at 24578-24578
  Backup superblock at 40961, Group descriptors at 40962-40962

  Используйте параметр -b с командой e2fsck, чтобы указать резервную копию, когда основной суперблок был поврежден. Например:

root@localhost:~# e2fsck -b 8193 /dev/sdb1
Команда fsck также может быть использована с той же опцией, так как она передаст эту опцию команде e2fsck:

root@localhost:~# fsck -b 8193 /dev/sdb1
> y

Чтобы найти номер суперблока, если главный суперблок поврежден, го команда:
mke2fs -n /dev/sdb5 - показывает где хранятся резервные суперблоки


XFS
xfs_repair - для восстановления xfs (только в размонтированной файловой системе)
xfs_copy и xfsdump
Команда xfs_copy может создать точную копию сомнительной файловой системы, чтобы поэкспериментировать с восстановлением.

xfs_repair -L /dev/sda3 - ообнулить журнал, только в крайнес случае, если лог журнала поврежден

xfs_fsr - дефрагментация

Прежде чем вызывать команду xfs_fsr для использования системных ресурсов для реорганизации файловых систем, рекомендуется проверить, не требуется ли им такое обслуживание. Для оценки необходимости реорганизации можно использовать команду xfs_db:

root@localhost:~# xfs_db -r /dev/sda3
xfs_db>frag
actual 345, ideal 289, fragmentation factor 16.23%
Note, this number is largely meaningless.
Files on this filesystem average 1.19 extents per file
xfs_db>quit

Использование команды internal frag сообщит о состоянии фрагментации файловой системы, и это будет работать как на смонтированных, так и на размонтированных файловых системах. Фрагментация файловой системы в примере довольно низкая, поэтому реорганизация, скорее всего, не даст практически никаких результатов производительности.
Если коэффициент фрагментации превышает 25% или около того, то реорганизация даст измеримые результаты производительности.

Еще одна очень полезная функция команды xfs_fsr заключается в том, что вы можете настроить ее на выполнение в течение определенного периода времени, поэтому она может быть запущена либо вручную, либо по расписанию, чтобы работать в течение нескольких часов каждую ночь, когда система менее загружена. Чтобы запустить xfs_fsr в течение 1 часа, а затем остановиться, выполните следующие действия:

root@localhost:~# xfs_fsr -t 3600

Если по какой-либо причине xfs_fsr прерывается или должна быть остановлена, он отслеживает, где он был в процессе реорганизации, и может возобновить работу с того места, где она остановилась, при повторном запуске.

        РАЗДЕЛЯЕМЫЕ БИБЛИОТЕКИ (shared librares)

Обычно находятся в папках /lib и /usr/lib , а также в файле /etc/ld.so.cache
ldconfig -v/-p - чтобы посмотреть где находятся файлы библиотек
Каталог //etc/ld.so.conf.d содержит файлы *.conf, в которых указаны каталоги библиотек
В эту папку можно добавить текстовый файл с путем до своей бибилиотеки, файл должен иметь расширение .conf
После добавления соей библиотеки надо обновить кэш командой ldconfig.
$LD_LIBRARY_PATH - переменная куда рользователи могут добавить путь до соих бибдиотек
export LD_LIBRARY_PATH=/home/jose/app/lib

ldd /bin/bash - посмотреть какие библиотеки связаны с программой (в данном примере с bash)

КВОТИРОВАНИЕ

quotaoff /mnt - отключить квоты если они были
sudo quotacheck -cug /mnt - create квоты для user and group
В директории появились двоичнве файлы настроек квоты
sudo edquota -u yura - создать квоту на user'a yura - счетчик soft - на неделю, hard - не более чем
sudo edquota -t - изменить время квот 
quotaon /mnt - включаем КВОТИРОВАНИЕ
repquota /mnt - сделать отчет по квотам
warnquota - отсылает сообщение на почту пользователя который превысил квоту

=======
modprobe - загружает в ядро модуль с зависимостями


                GRUB

/boot/grub/grub.cfg - содержит настройки, но его изменять нельзя
/etc/default/grub - можно изменять
update-grub - обновить инфу после смены настройке

                X server

 X -configure - создать файл конфигкрации x server   

Типичные дисплейные менеджеры, используемые в настоящее время, включают X Display Manager (XDM), KDE Display Manager (KDM), GNOME Display Manager (GDM) и MDM Display Manager (MDM; рекурсивная аббревиатура).
Как правило, эти диспетчеры отображения входят в desktop environment:

    Среда рабочего стола GNOME предоставляет диспетчер отображения gdm.
    Среда рабочего стола KDE предоставляет менеджер дисплея kdm.
    Если среда рабочего стола не установлена, используется диспетчер дисплея xdm.
    Некоторые дистрибутивы разработали свой собственный дисплейный менеджер. Например, диспетчер отображения для Ubuntu называется lightdm.

Будет ли экранный менеджер включен или выключен в большинстве дистрибутивов Linux, зависит от уровня запуска по умолчанию и дистрибутива. Для дистрибутивов, производных от Debian, это означает, что если уровень запуска по умолчанию находится в диапазоне от 2 до 5, то менеджер отображения будет запущен автоматически, если он установлен. Для Debian файл //etc/inittab определяет уровень запуска по умолчанию во втором поле следующей строки:

id:2:initdefault:

В системах, производных от Red Hat, та же строка в файле //etc/inittab определяет уровень запуска по умолчанию, а на уровне запуска 3 менеджер дисплея и графическая среда не запускаются, но если уровень запуска по умолчанию равен 5, то менеджер дисплея будет запущен, если все пройдет успешно:

id:5:initdefault:

Для дистрибутивов, производных от Debian, используйте команду dpkg-reconfigure для пакета, предоставляющего диспетчер отображения. Это позволяет выбрать, какой менеджер отображения использовать по умолчанию
Если система является дистрибутивом Linux на основе Red Hat, то файл //etc/sysconfig/desktop используется для установки диспетчера дисплея и окружения рабочего стола по умолчанию

gconftool-2 - команда для изменения приветственного баннера на RedHat

/etc/X11/xorg.conf - файл конфигурации X cсервера
Самые последние версии X-сервера могут работать без какого-либо файла xorg.conf, так как они автоматически настраиваются при запуске, но xorg.conf всё ещё может быть использован для создания пользовательских конфигурацийxorg.conf Ниже приведен список разделов, определенных для этого файла:
Секция 	Цель
Files 	

Пути к файлам для шрифтов и модулей
ServerFlags 	

Флаги сервера являются глобальными параметрами
Module 	

Динамическая загрузка модулей, расширяющих сервер
Extensions 	

Включение расширения для протокола X11
InputDevice 	

Описание устройства ввода для клавиатуры и указателей
InputClass 	

Описание входного класса
Device 	

Описание устройства видеокарты
VideoAdaptor 	

Описание видеоадаптера Xv
Monitor 	

Описание монитора
Modes 	

Описание видеорежимов
Screen 	

Конфигурация экрана
ServerLayout 	

Общая планировка, объединяющая другие секции
DRI 	

Инфраструктура прямого рендеринга
Vendor 	

Конфигурация в зависимости от поставщика


            RUNLEVELS

Runlevel 	Purpose 	                    systemd Target
0 	Halt or shut off the system 	    poweroff.target
1 	Single-user mode for administrative tasks   	rescue.target
2 	Multi-user mode without configured network interfaces or network services   	multi-user.target
3 	Normal startup of the system 	    multi-user.target
4 	User-definable  	multi-user.target
5 	Start the system normally with a graphical display manager  	graphical.target
6 	Restart the system 	    reboot.target            

runlevel - посмотреть текущий ранлевел
init 5
или
telinit 5 - перейти на уроверь 5


            ACCESSIBILITY

Several keyboard settings can be enabled by going to the Keyboard Accessibility settings of the GNOME desktop:

    Repeat Keys
    Sticky Keys
    Slow Keys
    Bounce Keys
    Toggle Keys
    Mouse Keys

Repeat Keys - позволяет предотвратить повторный ввод клавиши, если пользователь нажимает клавиши слишком медленно. Можно настраивать задержку.

Sticky Keys - позволяет настроить залипание клавишь, чтобы например при вводе заглавной буквы не удерживать клавишу SHIFT, а просто нажать шифт, а затем нужную букву.

Slow Keys - противоположна Repeat keys, и позволяет настроить ввод символа только если удерживаешь клавишу определенное время. Можно настроить задержку.
Это для тех кто слишком долго печатает и имеет heavy hands, случайно задевая другие клавиши при печатании.

Bounce Keys - предотвращает повторный ввод, если клавиша была нажата повторно слишком быстро

Toggle Keys - позволяет настроить звук или моргание экрана, когда нажимается одна из modifier keys (SHIFT, ALT, CTRL)

Mouse Keys - можно управлять курсором мыши используя клавиатуру.

            КОНСОЛИ

CTRL + ALT + F1/F2 и т.д. - переключаться на терминал
F7 - обычно это графическая среда

Команда tty - показывает в каком терминале мы находимся
Если путь /dev/tty1 - это настоящий терминал
А если /dev/pts/tty1 - это псевдотерминал

echo $DISPLAY - какой дисплей активен
    :0 - : значит что дисплей локальный , ноль что первый

CTRL + ALT + t - вызвать терминал

DISPLAY=192.168.0.248:0 - подключится к удаленному терминалу
xhost +192.168.0.247 - разрешить подключаться к дисплеям данному ip адресу


apt install gdm3 sddm - установить менеджер дисплея (входа в систему) GNOME и KDM
dpkg-reconfigure gdm3/sddm - изменить менеджер по дефолту
Какой из них запускать по дефолту отображено в файлку /etc/X11/defaul-display-manager



            SELinux

3 режима
- disabled - 
- permissive - ничего не блокируется, но логирует все нестандартное
- enforcing - блокируется все что не разрешено

getenforce - посмотреть текущий статуса
sestatus - тоже, но вывод полный

/etc/selinux/config - тут можно поменять режим
setenforce 0 - переводит в режим permissive
setenforce 1 - обратно в enforcing

ls -Z - показывает контекст
    unconfined_u:object_r:user_home_t:s0 file1
u - user
r - role
t - type (если отосится к файлу, то это домен) определяет у каких процессов к каким файлам, процессам, портам, устройствам есть доступ и какой именно

 semanage login -l - показать пользователей (селинукс не использует системных пользователей)

Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         s0-s0:c0.c1023       *
root                 unconfined_u         s0-s0:c0.c1023       *

К одному пользователю селинукса НЕОГРАНИЧЕННЫЙ привязаны обычные пользоваиели и рут 

Обычно настраивают не пользователей, а роли. У одного пользователя может быть больше одной роли

semanage user -l - посмотреть у какго пользователя какие роли

                Labeling   MLS/       MLS/
SELinux User    Prefix     MCS Level  MCS Range               SELinux Roles

guest_u         user       s0         s0                             guest_r
root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r
sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r
system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r
unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r
user_u          user       s0         s0                             user_r
xguest_u        user       s0         s0                             xguest_r

semanage port -l - посмотреть разрешения по портам


                FIREWALL

В ядре есть фреймворк netfilter (kernel space), а в пространстве пользователя фреймворки для управления (iptables, nftables), но они сами являются каркасом и есть программы (инструменты для управления) которые позволяют создавать политики.
Для iptables - iptables и ufw, а для nftables - firewalld и nft.

systemctl status firewalld - проаерить состояние

firewall-cmd --list-all - показывает всю инфу, что разрешено/запрещено и к кому это относится
sudo firewall-cmd --info-service=ssh - посмотреть инфу о сервисе
/lib/firewalld/services/ - тут хранятся настройки файервола для всех сервисов
firewall-cmd --add-port=2222/tcp - открыть портам
firewall-cmd --add-port=2222/tcp --permanent - чтобы изменения остались и после перезагрузки
firewall-cmd --list-services - посмотреть порты (стандартные) для каких сервисов открыты
firewall-cmd --remove-service=dhcpv6-client - убрать порты сервиса из разрешенных

firewall-cmd --permanent --service=ssh --remove-port=22/tcp - удалить порт из сервиса
firewall-cmd --permanent --service=ssh --add-port=22/tcp - добавить порт в сервис

cat /etc/protocols - посмотреть протоколы и их номера
sudo firewall-cmd --add-protocol=ospf - добавить протокол
firewall-cmd --add-icmp-block-inversion - запрет пинга
firewall-cmd --remove-icmp-block-inversion - разрешить пинг

firewall-cmd --set-target=DROP - чтобы пинги дропались

sudo firewall-cmd --get-zones - посмотреть зоны
sudo firewall-cmd --get-default-zone - показать зону по умолчанию
sudo firewall-cmd --list-all --zone=НАЗВАНИЕ_ЗОНЫ - посмотреть инфу по конкретной зоне 
sudo firewall-cmd --change-interface=НАЗВАНИЕ_ИНТКРФЕЙСА --zone=trusted - переместить интерфейс в зону 

При командах нужно указывать зону, если это не дефолтная зона 
sudo firewall-cmd --zone=block --add-source=IP_АДРЕСС - добавить ip адрес в зону блок

nc -zv 54.91.54.205 22 - утилита для проверки порта

можно тестить есть ли соединение прямо онлайн
на сервере: sudo nc -u(t)l 5555
на клиенте: nc -u(t) 54.91.54.205 5555 
            вводим любой текс и он отражается на сервере

sudo firewall-cmd --runtime-to-permanent - сохранить все изменения
sudo firewall-cmd --list-all-zones - посмотреть все зоны

sudo firewall-cmd --panic-o - режим паники обрывает все соединения

man firewalld.richlanguage - инфа как составлять правила отдельные
sudo firewall-cmd --add-rich-rule='правило' - добавить правило рич рул
sudo firewall-cmd --remove-rich-rule='правило' - удалить


                FAIL2BAN

 https://vps.ua/wiki/configuring-fail2ban/
                

sudo apt-get install fail2ban

Для того, чтобы установленное программное обеспечение работало должным образом, вам необходимо внести поправки в конфигурационный файл. По умолчанию таковым является /etc/fail2ban/jail.conf.

Однако разработчики крайне не рекомендуют редактировать его напрямую, чтобы избежать осложнений при работе с сервером. Поэтому создайте локальную копию данного файла командой:
    sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local

Далее вам нужно будет выполнять редактирование только /etc/fail2ban/jail.local. Он будет подключен системой автоматически и имеет высший приоритет при исполнении.

Существующие фильтры (т.е. правила, по которым определяется неудачная попытка ввода пароля) лежат в директории /etc/fail2ban/filter.d/ (можно их править или на их основе делать свои фильтры), а существующие правила реагирования - в директории /etc/fail2ban/action.d/


ignoreip — значения этого параметра говорят о том, какие IP-адреса блокироваться не будут вовсе. Если вы хотите, чтобы Fail2ban игнорировал при проверке несколько IP-адресов, их необходимо указать в значении ignoreip через пробел.

bantime — данный параметр означает время в секундах, в течение которого подозрительный IP будет заблокирован. Изначально его значение составляет 10 минут.

findtime — определяет промежуток времени в секундах, в течение которого программой будет определяться наличие подозрительной активности.

maxretry — допустимое число неуспешных попыток получения доступа к серверу. При превышении указанного значения IP попадает в бан.

service fail2ban restart - надо рестартануть сервис после изменения конфига 

Стоит обратить внимание на тот факт, что вовсе необязательно прописывать значения вышеуказанных параметров в каждой секции если настраиваешь конкретный сервис. Если их не упоминать, в действие вступят настройки, указанные в главном разделе [DEFAULT]. Главное, чтобы для переменной enabled было указано значение true.


                      

                      TIME

hwclock -r посмотреть системное время 

Functions:
 -r, --show           display the RTC time
     --get            display drift corrected RTC time
     --set            set the RTC according to --date
 -s, --hctosys        set the system time from the RTC (настроить системное время от аппаратного)
 -w, --systohc        set the RTC from the system time (настроить аппаратные часы, взяв знасение системного)
     --systz          send timescale configurations to the kernel
 -a, --adjust         adjust the RTC to account for systematic drift
     --predict        predict the drifted RTC time according to --date

Options:
 -u, --utc            the RTC timescale is UTC
 -l, --localtime      the RTC timescale is Local
 -f, --rtc <file>     use an alternate file to /dev/rtc0
     --directisa      use the ISA bus instead of /dev/rtc0 access
     --date <time>    date/time input for --set and --predict
     --delay <sec>    delay used when set new RTC time
     --update-drift   update the RTC drift factor
     --noadjfile      do not use /etc/adjtime
     --adjfile <file> use an alternate file to /etc/adjtime
     --test           dry run; implies --verbose
 -v, --verbose        display more details

 -h, --help           display this help
 -V, --version        display version

root@localhost:~# date "+%m/%d/%y"                                              
12/17/24

Specifier 	Meaning
%d 	Day of month (e.g., 30)
%H 	Hour (0-23)
%I 	Hour (1-12)
%m 	Month (1-12)
%M 	Minute (0-59)
%S 	Seconds (0-60)
%T 	Time (%H:%M:%S)
%u 	Day of week (1-7, 1=Monday)
%Y 	Year
%F 	Full date; same as %Y-%m-%d

Создание лога 
mv app_log app_log_`date +%F`                             
ls app*                                                   
    app_log_2025-12-17

 date -s "01/02/2025 3:00:00"  - сменить системное время

                            NTP 

ntpd 
Option 	Meaning
-g 	Allow ntpd to be started on a system whose clock has crossed the panic threshold (1000 secs by default)
-n 	Do not run ntpd as a daemon (i.e., run it as a foreground process)
-c file_name 	Use the specified file for configuration instead of the default file (the /etc/ntp.conf file)
-N 	Run at the highest possible priority
-q 	Quit after setting the time (i.e., one-time synchronization)

/etc/ntp.conf - файл конфигкрации ntp

ntpg -pn - показывает ntp серверы от первых до самых корневых

ntpdate 2.asia.pool.ntp.org - настроить время использу данный сервер 
так же как 
ntpd -q 

timedatectl - для систем с systemd
timedatectl set-local-rtc 0 - установить HW часы на UTC

chrony
chronyc - команда для настройки времени

Argument 	Description
tracking 	Displays performance statistics about the system clock

sources 	Displays the NTP sources being used for chronyd

activity 	 Displays the status of NTP sources

settime <TIME> 	 Allows you to manually set the time used for chronyd. The format for settime can be any of the below:

hh:mm

hh:mm:ss

Month Day, YYYY hh:mm:ss

/etc/chrony.conf- конфиг chronyd


